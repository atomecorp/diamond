{
  "version": 3,
  "sources": ["../src/tokenizer.js", "../src/parser.js", "../src/emitter.js", "../src/transpiler.js"],
  "sourcesContent": ["class Tokenizer {\n  constructor(input) {\n    this.input = input;\n    this.position = 0;\n    this.line = 1;\n    this.column = 1;\n    this.tokens = [];\n    this.keywords = new Set([\n      'def', 'end', 'class', 'module', 'if', 'elsif', 'else', 'unless', 'while', 'until', 'loop', 'do', 'then',\n      'case', 'when', 'in', 'true', 'false', 'nil', 'return', 'self', 'break', 'yield', 'using', 'super',\n      'begin', 'rescue', 'ensure'\n    ]);\n    this.multiChar = [\n      '===', '==', '!=', '<=', '>=', '=>', '...', '..', '::', '&&=', '&&', '||=', '||', '**', '+=', '-=', '*=', '/=', '%=',\n      '<<', '>>', '<=>', '=~', '!~', '&.', '->'\n    ];\n    this.singleChar = new Set([\n      '(', ')', '{', '}', '[', ']', ',', '.', ':', ';', '+', '-', '*', '/', '%', '<', '>', '=', '!', '?',\n      '\\\\', '|', '&', '@', '^'\n    ]);\n  }\n\n  tokenize() {\n    while (!this.isEOF()) {\n      const char = this.peek();\n\n      if (this.isWhitespace(char)) {\n        this.consumeWhitespace();\n        continue;\n      }\n\n      if (char === '#') {\n        this.consumeComment();\n        continue;\n      }\n\n      const heredoc = this.tryConsumeHeredoc();\n      if (heredoc) {\n        this.tokens.push(heredoc);\n        continue;\n      }\n\n      if (char === '%' && (this.peek(1) === 'w' || this.peek(1) === 'W')) {\n        this.tokens.push(this.consumePercentStringArray());\n        continue;\n      }\n\n      if (char === '\\\"' || char === '\\'') {\n        this.tokens.push(this.consumeString());\n        continue;\n      }\n\n      if (char === '/' && this.isRegexStart()) {\n        this.tokens.push(this.consumeRegex());\n        continue;\n      }\n\n      if (this.isDigit(char)) {\n        this.tokens.push(this.consumeNumber());\n        continue;\n      }\n\n      if (this.isIdentifierStart(char) || (char === '@' && this.isIdentifierStart(this.peek(1)))) {\n        this.tokens.push(this.consumeIdentifier());\n        continue;\n      }\n\n      const multi = this.matchMultiChar();\n      if (multi) {\n        this.tokens.push(this.createToken('OPERATOR', multi.value));\n        this.advance(multi.length);\n        continue;\n      }\n\n      if (this.singleChar.has(char)) {\n        this.tokens.push(this.createToken('OPERATOR', char));\n        this.advance();\n        continue;\n      }\n\n      if (char === '\\n') {\n        this.tokens.push(this.createToken('NEWLINE', '\\n'));\n        this.advance();\n        this.line += 1;\n        this.column = 1;\n        continue;\n      }\n\n      throw new SyntaxError(`Unexpected character '${char}' at ${this.line}:${this.column}`);\n    }\n\n    this.tokens.push(this.createToken('EOF', null));\n    return this.tokens;\n  }\n\n  isRegexStart() {\n    const prev = this.tokens[this.tokens.length - 1];\n    if (!prev) return true;\n    if (prev.type === 'NEWLINE') return true;\n    if (prev.type === 'OPERATOR') {\n      const disallow = new Set([')', ']', '}', '?']);\n      return !disallow.has(prev.value);\n    }\n    if (prev.type === 'KEYWORD') {\n      return ['if', 'elsif', 'unless', 'when', 'in', 'while', 'until', 'return', 'do', 'then'].includes(prev.value);\n    }\n    return false;\n  }\n\n  consumeRegex() {\n    const startLine = this.line;\n    const startColumn = this.column;\n    this.advance();\n    let pattern = '';\n    let escaped = false;\n    let inCharClass = false;\n    let charClassCanClose = false;\n\n    while (!this.isEOF()) {\n      const char = this.peek();\n      if (escaped) {\n        pattern += char;\n        escaped = false;\n        this.advance();\n        if (inCharClass) charClassCanClose = true;\n        continue;\n      }\n\n      if (char === '\\\\') {\n        pattern += char;\n        escaped = true;\n        this.advance();\n        continue;\n      }\n\n      if (char === '\\n') {\n        throw new SyntaxError(`Unterminated regex literal at ${startLine}:${startColumn}`);\n      }\n\n      if (inCharClass) {\n        if (char === ']' && charClassCanClose) {\n          pattern += char;\n          this.advance();\n          inCharClass = false;\n          charClassCanClose = false;\n          continue;\n        }\n        pattern += char;\n        this.advance();\n        if (!charClassCanClose) charClassCanClose = true;\n        continue;\n      }\n\n      if (char === '[') {\n        inCharClass = true;\n        charClassCanClose = false;\n        pattern += char;\n        this.advance();\n        continue;\n      }\n\n      if (char === '/') {\n        break;\n      }\n\n      pattern += char;\n      this.advance();\n    }\n\n    if (escaped || inCharClass) {\n      throw new SyntaxError(`Unterminated regex literal at ${startLine}:${startColumn}`);\n    }\n\n    if (this.peek() !== '/') {\n      throw new SyntaxError(`Unterminated regex literal at ${startLine}:${startColumn}`);\n    }\n\n    this.advance();\n\n    let flags = '';\n    while (!this.isEOF()) {\n      const char = this.peek();\n      if (!/[a-z]/i.test(char)) break;\n      flags += char;\n      this.advance();\n    }\n\n    return this.createToken('REGEX', { pattern, flags }, startLine, startColumn);\n  }\n\n  isEOF() {\n    return this.position >= this.input.length;\n  }\n\n  peek(ahead = 0) {\n    return this.input[this.position + ahead];\n  }\n\n  advance(step = 1) {\n    this.position += step;\n    this.column += step;\n  }\n\n  isWhitespace(char) {\n    return char === ' ' || char === '\\t' || char === '\\r';\n  }\n\n  consumeWhitespace() {\n    while (!this.isEOF()) {\n      const char = this.peek();\n      if (char === ' ' || char === '\\t' || char === '\\r') {\n        this.advance();\n      } else if (char === '\\n') {\n        // newline handled separately to preserve statement boundaries\n        break;\n      } else {\n        break;\n      }\n    }\n  }\n\n  consumeComment() {\n    while (!this.isEOF() && this.peek() !== '\\n') {\n      this.advance();\n    }\n  }\n\n  consumeString() {\n    const quote = this.peek();\n    let value = '';\n    let escaped = false;\n    const startLine = this.line;\n    const startColumn = this.column;\n    this.advance();\n\n    while (!this.isEOF()) {\n      const char = this.peek();\n      if (escaped) {\n        value += this.translateEscape(char);\n        escaped = false;\n        this.advance();\n        continue;\n      }\n\n      if (char === '\\\\') {\n        escaped = true;\n        this.advance();\n        continue;\n      }\n\n      if (char === quote) {\n        this.advance();\n        return this.createToken('STRING', value, startLine, startColumn);\n      }\n\n      if (char === '\\n') {\n        throw new SyntaxError(`Unterminated string literal at ${startLine}:${startColumn}`);\n      }\n\n      value += char;\n      this.advance();\n    }\n\n    throw new SyntaxError(`Unterminated string literal at ${startLine}:${startColumn}`);\n  }\n\n  translateEscape(char) {\n    const map = { n: '\\n', t: '\\t', r: '\\r', '\\\\': '\\\\', '\\\"': '\\\"', \"'\": \"'\" };\n    return map[char] ?? char;\n  }\n\n  isDigit(char) {\n    return /[0-9]/.test(char);\n  }\n\n  consumeNumber() {\n    let value = '';\n    const startLine = this.line;\n    const startColumn = this.column;\n    while (!this.isEOF() && /[0-9_]/.test(this.peek())) {\n      value += this.peek();\n      this.advance();\n    }\n    if (!this.isEOF() && this.peek() === '.') {\n      if (this.isDigit(this.peek(1))) {\n        value += '.';\n        this.advance();\n        while (!this.isEOF() && /[0-9_]/.test(this.peek())) {\n          value += this.peek();\n          this.advance();\n        }\n      }\n    }\n    value = value.replace(/_/g, '');\n    return this.createToken('NUMBER', value, startLine, startColumn);\n  }\n\n  isIdentifierStart(char) {\n    return /[A-Za-z_]/.test(char);\n  }\n\n  isIdentifierPart(char) {\n    return /[A-Za-z0-9_?!]/.test(char);\n  }\n\n  consumeIdentifier() {\n    const startLine = this.line;\n    const startColumn = this.column;\n    let value = '';\n\n    if (this.peek() === '@') {\n      value += '@';\n      this.advance();\n      if (this.peek() === '@') {\n        value += '@';\n        this.advance();\n      }\n    }\n\n    while (!this.isEOF() && this.isIdentifierPart(this.peek())) {\n      value += this.peek();\n      this.advance();\n    }\n\n    const type = this.keywords.has(value) ? 'KEYWORD' : 'IDENTIFIER';\n    return this.createToken(type, value, startLine, startColumn);\n  }\n\n  matchMultiChar() {\n    for (const op of this.multiChar) {\n      if (this.input.startsWith(op, this.position)) {\n        return { value: op, length: op.length };\n      }\n    }\n    return null;\n  }\n\n  createToken(type, value, line = this.line, column = this.column) {\n    return { type, value, line, column };\n  }\n\n  tryConsumeHeredoc() {\n    if (this.peek() !== '<' || this.peek(1) !== '<') {\n      return null;\n    }\n\n    const startPos = this.position;\n    const startLine = this.line;\n    const startColumn = this.column;\n\n    this.advance(2); // consume <<\n\n    let indicator = '';\n    if (this.peek() === '~' || this.peek() === '-') {\n      indicator = this.peek();\n      this.advance();\n    }\n\n    const labelStart = this.position;\n    while (!this.isEOF() && this.isIdentifierPart(this.peek())) {\n      this.advance();\n    }\n\n    if (this.position === labelStart) {\n      this.position = startPos;\n      this.column = startColumn;\n      return null;\n    }\n\n    const label = this.input.slice(labelStart, this.position);\n\n    if (this.peek() === '\\r') {\n      this.advance();\n    }\n\n    if (this.peek() !== '\\n') {\n      this.position = startPos;\n      this.column = startColumn;\n      return null;\n    }\n\n    this.advance();\n    this.line += 1;\n    this.column = 1;\n\n    const lines = [];\n    let currentLine = '';\n    while (!this.isEOF()) {\n      const char = this.peek();\n      if (char === '\\n') {\n        const trimmed = currentLine.trim();\n        if (trimmed === label && trimmed.length === label.length) {\n          this.advance();\n          this.line += 1;\n          this.column = 1;\n          const value = this.buildHeredocValue(lines, indicator === '~');\n          return this.createToken('STRING', value, startLine, startColumn);\n        }\n        lines.push(currentLine);\n        currentLine = '';\n        this.advance();\n        this.line += 1;\n        this.column = 1;\n        continue;\n      }\n\n      currentLine += char;\n      this.advance();\n    }\n\n    throw new SyntaxError(`Unterminated heredoc <<${indicator}${label}`);\n  }\n\n  buildHeredocValue(lines, dedent) {\n    if (!lines.length) return '\\n';\n    let processed = lines;\n    if (dedent) {\n      let minIndent = null;\n      for (const line of lines) {\n        if (!line.trim()) continue;\n        const match = line.match(/^\\s*/);\n        const indent = match ? match[0].length : 0;\n        if (minIndent === null || indent < minIndent) {\n          minIndent = indent;\n        }\n      }\n      if (minIndent && minIndent > 0) {\n        processed = lines.map(line => line.startsWith(' '.repeat(minIndent)) ? line.slice(minIndent) : line);\n      }\n    }\n    return processed.join('\\n') + '\\n';\n  }\n\n  consumePercentStringArray() {\n    const startLine = this.line;\n    const startColumn = this.column;\n    const isInterpolated = this.peek(1) === 'W';\n    this.advance(2); // consume %w or %W\n\n    const opening = this.peek();\n    const closing = this.matchingDelimiter(opening);\n    if (!closing) {\n      throw new SyntaxError(`Unsupported delimiter for %w literal at ${startLine}:${startColumn}`);\n    }\n\n    this.advance(); // consume opening delimiter\n\n    let buffer = '';\n    const values = [];\n    let escaped = false;\n\n    while (!this.isEOF()) {\n      const char = this.peek();\n\n      if (!escaped && char === closing) {\n        this.advance();\n        if (buffer.length) {\n          values.push(buffer);\n        }\n        return this.createToken('PERCENT_STRING_ARRAY', { values, interpolated: isInterpolated }, startLine, startColumn);\n      }\n\n      if (!escaped && char === '\\\\') {\n        escaped = true;\n        this.advance();\n        continue;\n      }\n\n      if (!escaped && /\\s/.test(char)) {\n        if (buffer.length) {\n          values.push(buffer);\n          buffer = '';\n        }\n        this.advance();\n        if (char === '\\n') {\n          this.line += 1;\n          this.column = 1;\n        }\n        continue;\n      }\n\n      buffer += char;\n      escaped = false;\n      this.advance();\n      if (char === '\\n') {\n        this.line += 1;\n        this.column = 1;\n      }\n    }\n\n    throw new SyntaxError(`Unterminated %w literal starting at ${startLine}:${startColumn}`);\n  }\n\n  matchingDelimiter(opening) {\n    const pairs = {\n      '(': ')',\n      '[': ']',\n      '{': '}',\n      '<': '>'\n    };\n    return pairs[opening] || opening;\n  }\n}\n\nmodule.exports = { Tokenizer };\n", "class Parser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.current = 0;\n    this.allowMultiAssign = true;\n  }\n\n  parse() {\n    const body = [];\n    while (!this.check('EOF')) {\n      this.skipNewlines();\n      if (this.check('EOF')) break;\n      body.push(this.parseStatement());\n      this.consumeStatementTerminator();\n    }\n    return { type: 'Program', body };\n  }\n\n  parseStatement() {\n    this.allowMultiAssign = true;\n    if (this.match('KEYWORD', 'def')) return this.parseMethodDefinition();\n    if (this.match('KEYWORD', 'class')) return this.parseClassDefinition();\n    if (this.match('KEYWORD', 'module')) return this.parseModuleDeclaration();\n    if (this.match('KEYWORD', 'if')) return this.parseIfStatement();\n    if (this.match('KEYWORD', 'unless')) return this.parseUnlessStatement();\n    if (this.match('KEYWORD', 'while')) return this.parseWhileStatement();\n    if (this.match('KEYWORD', 'loop')) return this.parseLoopStatement();\n    if (this.match('KEYWORD', 'case')) return this.parseCaseStatement();\n    if (this.match('KEYWORD', 'return')) return this.parseReturnStatement();\n    if (this.match('KEYWORD', 'break')) return { type: 'BreakStatement' };\n    if (this.match('KEYWORD', 'using')) return this.parseUsingStatement();\n\n    const expr = this.parseAssignment();\n\n    if (this.check('KEYWORD', 'if') || this.check('KEYWORD', 'unless')) {\n      const modifier = this.advance();\n      const test = this.parseExpression();\n      const expressionStmt = { type: 'ExpressionStatement', expression: expr };\n      if (modifier.value === 'if') {\n        return {\n          type: 'IfStatement',\n          test,\n          consequent: { type: 'BlockStatement', body: [expressionStmt] },\n          alternate: null\n        };\n      }\n\n      return {\n        type: 'IfStatement',\n        test,\n        consequent: null,\n        alternate: { type: 'BlockStatement', body: [expressionStmt] }\n      };\n    }\n\n    return { type: 'ExpressionStatement', expression: expr };\n  }\n\n  parseMethodDefinition() {\n    const { target, name } = this.parseMethodTargetAndName();\n\n    const params = this.parseMethodParameters();\n\n    this.consumeStatementTerminator();\n    const body = this.parseBlock(['end']);\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close method definition\");\n\n    const bodyNode = { type: 'BlockStatement', body };\n    const methodNode = {\n      type: 'MethodDefinition',\n      id: { type: 'Identifier', name },\n      target,\n      params,\n      body: bodyNode\n    };\n\n    if (this.containsYield(bodyNode)) {\n      methodNode.usesYield = true;\n    }\n\n    return methodNode;\n  }\n\n  parseMethodTargetAndName() {\n    let target = null;\n\n    if (this.check('KEYWORD', 'self') && this.peekNextIs('.')) {\n      this.advance(); // consume self\n      target = { type: 'SelfExpression' };\n      this.advance(); // consume '.'\n      const name = this.parseMethodName();\n      return { target, name };\n    }\n\n    if (this.check('IDENTIFIER') && this.peekNextIs('.')) {\n      const receiver = this.advance();\n      target = { type: 'Identifier', name: receiver.value };\n      this.advance(); // consume '.'\n      const name = this.parseMethodName();\n      return { target, name };\n    }\n\n    const name = this.parseMethodName();\n    return { target, name };\n  }\n\n  parseMethodName() {\n    if (this.check('IDENTIFIER') || this.check('KEYWORD')) {\n      const token = this.advance();\n      let name = token.value;\n      if (this.match('OPERATOR', '=')) {\n        name += '=';\n      }\n      return name;\n    }\n\n    if (this.match('OPERATOR', '[')) {\n      this.consume('OPERATOR', ']', \"Expected ']' after '[' in method name\");\n      let name = '[]';\n      if (this.match('OPERATOR', '=')) {\n        name += '=';\n      }\n      return name;\n    }\n\n    const operatorToken = this.matchOperatorMethodToken();\n    if (operatorToken) {\n      return operatorToken;\n    }\n\n    throw new SyntaxError('Expected method name after def');\n  }\n\n  matchOperatorMethodToken() {\n    const token = this.peek();\n    if (!token || token.type !== 'OPERATOR') return null;\n\n    const simpleOperators = new Set([\n      '+', '-', '*', '/', '%', '**', '<<', '>>', '&', '|', '^', '<', '<=', '>', '>=', '==', '===', '!=',\n      '<=>', '=~', '!~', '!', '~'\n    ]);\n\n    if (token.value === '+' || token.value === '-' || token.value === '~') {\n      this.advance();\n      if (this.match('OPERATOR', '@')) {\n        return token.value + '@';\n      }\n      if (this.check('OPERATOR', '=')) {\n        this.advance();\n        return token.value + '=';\n      }\n      return token.value;\n    }\n\n    if (simpleOperators.has(token.value)) {\n      this.advance();\n      return token.value;\n    }\n\n    return null;\n  }\n\n  parseModuleDeclaration() {\n    const nameToken = this.consume('IDENTIFIER', undefined, 'Expected module name');\n    this.consumeStatementTerminator();\n    const body = this.parseBlock(['end']);\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close module\");\n    return {\n      type: 'ModuleDeclaration',\n      id: { type: 'Identifier', name: nameToken.value },\n      body: { type: 'BlockStatement', body }\n    };\n  }\n\n  parseUsingStatement() {\n    const nameToken = this.consumeIdentifier('Expected refinement module name after using');\n    return {\n      type: 'UsingStatement',\n      id: { type: 'Identifier', name: nameToken.value }\n    };\n  }\n\n  parseMethodParameters() {\n    const params = [];\n    if (!this.match('OPERATOR', '(')) {\n      return params;\n    }\n\n    if (!this.check('OPERATOR', ')')) {\n      while (true) {\n        if (this.match('OPERATOR', '...')) {\n          params.push({ type: 'ForwardingParameter' });\n          break;\n        }\n\n        if (this.match('OPERATOR', '**')) {\n          const kwRest = this.consumeIdentifier('Expected keyword rest parameter name');\n          params.push({ type: 'KeywordRestParameter', name: kwRest.value });\n          if (!this.match('OPERATOR', ',')) break;\n          continue;\n        }\n\n        if (this.match('OPERATOR', '*')) {\n          if (this.match('OPERATOR', '*')) {\n            const kwRest = this.consumeIdentifier('Expected keyword rest parameter name');\n            params.push({ type: 'KeywordRestParameter', name: kwRest.value });\n          } else {\n            const rest = this.consumeIdentifier('Expected rest parameter name');\n            params.push({ type: 'RestParameter', name: rest.value });\n          }\n          if (!this.match('OPERATOR', ',')) break;\n          continue;\n        }\n\n        if (this.match('OPERATOR', '&')) {\n          if (this.check('IDENTIFIER') || this.check('KEYWORD')) {\n            const block = this.advance();\n            params.push({ type: 'BlockParameter', name: block.value });\n          } else {\n            params.push({ type: 'BlockParameter', name: '__block' });\n          }\n          if (!this.match('OPERATOR', ',')) break;\n          continue;\n        }\n\n        const paramToken = this.consumeIdentifier('Expected parameter name');\n\n        if (this.match('OPERATOR', '=')) {\n          const defaultValue = this.parseExpression();\n          params.push({\n            type: 'OptionalParameter',\n            name: paramToken.value,\n            default: defaultValue\n          });\n          if (!this.match('OPERATOR', ',')) break;\n          continue;\n        }\n\n        if (this.check('OPERATOR', ':')) {\n          this.advance();\n          this.skipNewlines();\n          if (this.check('OPERATOR', ',') || this.check('OPERATOR', ')')) {\n            params.push({ type: 'KeywordParameter', name: paramToken.value });\n          } else {\n            const defaultValue = this.parseExpression();\n            params.push({\n              type: 'KeywordOptionalParameter',\n              name: paramToken.value,\n              default: defaultValue\n            });\n          }\n          if (!this.match('OPERATOR', ',')) break;\n          continue;\n        }\n\n        params.push({ type: 'Identifier', name: paramToken.value });\n        if (!this.match('OPERATOR', ',')) break;\n      }\n    }\n\n    this.consume('OPERATOR', ')', 'Expected closing ) after parameters');\n    return params;\n  }\n\n  parseClassDefinition() {\n    if (this.match('OPERATOR', '<<')) {\n      const target = this.parseExpression();\n      this.consumeStatementTerminator();\n      const body = this.parseBlock(['end']);\n      this.consume('KEYWORD', 'end', \"Expected 'end' to close singleton class block\");\n      return {\n        type: 'SingletonClassDeclaration',\n        target,\n        body: { type: 'BlockStatement', body }\n      };\n    }\n\n    const nameToken = this.consume('IDENTIFIER', undefined, 'Expected class name');\n    let superClass = null;\n    if (this.match('OPERATOR', '<')) {\n      superClass = this.parsePrimary();\n    }\n\n    this.consumeStatementTerminator();\n    const body = this.parseBlock(['end']);\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close class\");\n\n    return {\n      type: 'ClassDeclaration',\n      id: { type: 'Identifier', name: nameToken.value },\n      superClass,\n      body: { type: 'BlockStatement', body }\n    };\n  }\n\n  parseIfStatement() {\n    const test = this.parseExpression();\n    this.consumeOptionalThen();\n    this.consumeStatementTerminator();\n    const consequent = this.parseBlock(['elsif', 'else', 'end']);\n\n    let alternate = null;\n    if (this.match('KEYWORD', 'elsif')) {\n      alternate = this.parseIfStatement();\n    } else if (this.match('KEYWORD', 'else')) {\n      this.consumeStatementTerminator();\n      const alternateBody = this.parseBlock(['end']);\n      this.consume('KEYWORD', 'end', \"Expected 'end' to close else branch\");\n      alternate = { type: 'BlockStatement', body: alternateBody };\n      return {\n        type: 'IfStatement',\n        test,\n        consequent: { type: 'BlockStatement', body: consequent },\n        alternate\n      };\n    } else {\n      this.consume('KEYWORD', 'end', \"Expected 'end' to close if statement\");\n    }\n\n    return {\n      type: 'IfStatement',\n      test,\n      consequent: { type: 'BlockStatement', body: consequent },\n      alternate\n    };\n  }\n\n  parseUnlessStatement() {\n    const test = this.parseExpression();\n    this.consumeOptionalThen();\n    this.consumeStatementTerminator();\n    const mainBody = this.parseBlock(['else', 'end']);\n\n    let elseBody = null;\n    if (this.match('KEYWORD', 'else')) {\n      this.consumeStatementTerminator();\n      elseBody = this.parseBlock(['end']);\n    }\n\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close unless statement\");\n\n    const alternateBlock = { type: 'BlockStatement', body: mainBody };\n    const consequentBlock = elseBody\n      ? { type: 'BlockStatement', body: elseBody }\n      : { type: 'BlockStatement', body: [] };\n\n    return {\n      type: 'IfStatement',\n      test,\n      consequent: consequentBlock,\n      alternate: alternateBlock\n    };\n  }\n\n  parseWhileStatement() {\n    const test = this.parseExpression();\n    this.consumeStatementTerminator();\n    const body = this.parseBlock(['end']);\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close while\");\n    return {\n      type: 'WhileStatement',\n      test,\n      body: { type: 'BlockStatement', body }\n    };\n  }\n\n  parseLoopStatement() {\n    this.consume('KEYWORD', 'do', \"Expected 'do' after loop\");\n    this.consumeStatementTerminator();\n    const body = this.parseBlock(['end']);\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close loop\");\n    return {\n      type: 'LoopStatement',\n      body: { type: 'BlockStatement', body }\n    };\n  }\n\n  parseCaseStatement() {\n    let test = null;\n    if (!this.check('NEWLINE') && !this.check('KEYWORD', 'when') && !this.check('KEYWORD', 'in')) {\n      test = this.parseExpression();\n    }\n    this.consumeStatementTerminator();\n\n    const clauses = [];\n    while (true) {\n      if (this.match('KEYWORD', 'when')) {\n        const tests = [];\n        do {\n          tests.push(this.parseExpression());\n        } while (this.match('OPERATOR', ','));\n        this.consumeStatementTerminator();\n        const body = this.parseBlock(['when', 'in', 'else', 'end']);\n        clauses.push({ type: 'WhenClause', tests, body: { type: 'BlockStatement', body } });\n        continue;\n      }\n      if (this.match('KEYWORD', 'in')) {\n        const pattern = this.parsePattern();\n        let guard = null;\n        if (this.match('KEYWORD', 'if')) {\n          guard = { type: 'PatternGuard', condition: this.parseExpression(), negated: false };\n        } else if (this.match('KEYWORD', 'unless')) {\n          guard = { type: 'PatternGuard', condition: this.parseExpression(), negated: true };\n        }\n        this.match('KEYWORD', 'then');\n        this.consumeStatementTerminator();\n        const body = this.parseBlock(['when', 'in', 'else', 'end']);\n        clauses.push({ type: 'PatternClause', pattern, guard, body: { type: 'BlockStatement', body } });\n        continue;\n      }\n      break;\n    }\n\n    let alternate = null;\n    if (this.match('KEYWORD', 'else')) {\n      this.consumeStatementTerminator();\n      const altBody = this.parseBlock(['end']);\n      alternate = { type: 'BlockStatement', body: altBody };\n    }\n\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close case statement\");\n\n    return { type: 'CaseStatement', test, clauses, alternate };\n  }\n\n  parseReturnStatement() {\n    const modifierAhead = this.check('KEYWORD', 'if') || this.check('KEYWORD', 'unless');\n    if (this.isTerminator(this.peek()) || modifierAhead) {\n      const statement = { type: 'ReturnStatement', argument: null };\n      if (modifierAhead && (this.match('KEYWORD', 'if') || this.match('KEYWORD', 'unless'))) {\n        const keyword = this.previous().value;\n        const test = this.parseExpression();\n        if (keyword === 'if') {\n          return {\n            type: 'IfStatement',\n            test,\n            consequent: { type: 'BlockStatement', body: [statement] },\n            alternate: null\n          };\n        }\n        return {\n          type: 'IfStatement',\n          test: { type: 'UnaryExpression', operator: '!', argument: test },\n          consequent: { type: 'BlockStatement', body: [statement] },\n          alternate: null\n        };\n      }\n      return statement;\n    }\n\n    const argument = this.parseExpression();\n    const statement = { type: 'ReturnStatement', argument };\n    if (this.match('KEYWORD', 'if') || this.match('KEYWORD', 'unless')) {\n      const keyword = this.previous().value;\n      const test = this.parseExpression();\n      if (keyword === 'if') {\n        return {\n          type: 'IfStatement',\n          test,\n          consequent: { type: 'BlockStatement', body: [statement] },\n          alternate: null\n        };\n      }\n      return {\n        type: 'IfStatement',\n        test: { type: 'UnaryExpression', operator: '!', argument: test },\n        consequent: { type: 'BlockStatement', body: [statement] },\n        alternate: null\n      };\n    }\n    return statement;\n  }\n\n  parsePattern() {\n    if (this.match('OPERATOR', '{')) {\n      return this.parseHashPattern(true);\n    }\n    if (this.match('OPERATOR', '[')) {\n      return this.parseArrayPattern(true);\n    }\n    if (this.check('IDENTIFIER')) {\n      const identifier = this.advance();\n      return { type: 'Identifier', name: identifier.value };\n    }\n    if (this.match('OPERATOR', '*')) {\n      const restName = this.consumeIdentifier('Expected identifier after * in pattern');\n      return { type: 'RestPattern', argument: { type: 'Identifier', name: restName.value } };\n    }\n    return this.parseExpression();\n  }\n\n  parseHashPattern(openConsumed = false) {\n    if (!openConsumed) {\n      this.consume('OPERATOR', '{', \"Expected '{' to start hash pattern\");\n    }\n    const entries = [];\n    while (!this.check('OPERATOR', '}')) {\n      this.skipNewlines();\n      if (this.check('OPERATOR', '}')) break;\n\n      let keyNode;\n      let binding = null;\n      let value = null;\n\n      if (this.check('STRING')) {\n        const keyToken = this.advance();\n        keyNode = { type: 'StringLiteral', value: keyToken.value };\n        this.consume('OPERATOR', '=>', \"Expected '=>' after string key in pattern\");\n        const bindingToken = this.consume('IDENTIFIER', undefined, 'Expected binding name in pattern');\n        binding = { type: 'Identifier', name: bindingToken.value };\n      } else if (this.check('IDENTIFIER')) {\n        const labelToken = this.advance();\n        keyNode = { type: 'SymbolLiteral', name: labelToken.value };\n        this.consume('OPERATOR', ':', \"Expected ':' after key in pattern\");\n        if (this.check('IDENTIFIER') && !this.peekNextIs(':')) {\n          const bindingToken = this.advance();\n          binding = { type: 'Identifier', name: bindingToken.value };\n        } else if (this.check('OPERATOR', '^')) {\n          this.advance();\n          value = { type: 'PinExpression', expression: this.parseExpression() };\n        } else if (this.check('OPERATOR', '{')) {\n          value = this.parseHashPattern();\n        } else if (this.check('OPERATOR', '[')) {\n          value = this.parseArrayPattern();\n        } else if (this.isPatternValueStart(this.peek())) {\n          value = this.parsePatternValue();\n        } else {\n          binding = { type: 'Identifier', name: labelToken.value };\n        }\n      } else {\n        throw new SyntaxError('Unsupported hash pattern entry');\n      }\n\n      entries.push({ key: keyNode, binding, value });\n      this.match('OPERATOR', ',');\n      this.skipNewlines();\n    }\n\n    this.consume('OPERATOR', '}', \"Expected '}' to close pattern\");\n    return { type: 'HashPattern', entries };\n  }\n\n  parseArrayPattern(openConsumed = false) {\n    if (!openConsumed) {\n      this.consume('OPERATOR', '[', \"Expected '[' to start array pattern\");\n    }\n\n    const elements = [];\n    let restElement = null;\n\n    while (!this.check('OPERATOR', ']')) {\n      this.skipNewlines();\n      if (this.check('OPERATOR', ']')) break;\n\n      if (this.match('OPERATOR', '*')) {\n        if (this.check('IDENTIFIER')) {\n          const token = this.advance();\n          restElement = { type: 'Identifier', name: token.value };\n        } else {\n          restElement = { type: 'Identifier', name: null };\n        }\n        break;\n      }\n\n      const element = this.parsePatternValue();\n      elements.push(element);\n      this.skipNewlines();\n      if (!this.match('OPERATOR', ',')) break;\n    }\n\n    this.consume('OPERATOR', ']', \"Expected ']' to close pattern\");\n    return { type: 'ArrayPattern', elements, rest: restElement };\n  }\n\n  parsePatternValue() {\n    if (this.match('OPERATOR', '^')) {\n      return { type: 'PinExpression', expression: this.parseExpression() };\n    }\n\n    if (this.match('OPERATOR', '{')) {\n      return this.parseHashPattern(true);\n    }\n\n    if (this.match('OPERATOR', '[')) {\n      return this.parseArrayPattern(true);\n    }\n\n    if (this.check('IDENTIFIER')) {\n      const token = this.advance();\n      return { type: 'Identifier', name: token.value };\n    }\n\n    return this.parseExpression();\n  }\n\n  isPatternValueStart(token) {\n    if (!token) return false;\n    if (token.type === 'IDENTIFIER') return true;\n    if (token.type === 'NUMBER' || token.type === 'STRING') return true;\n    if (token.type === 'OPERATOR' && ['{', '[', '^'].includes(token.value)) return true;\n    return false;\n  }\n\n  parseBlock(stopKeywords) {\n    const body = [];\n    while (!this.check('EOF') && !this.checkAny(stopKeywords)) {\n      this.skipNewlines();\n      if (this.checkAny(stopKeywords)) break;\n      body.push(this.parseStatement());\n      this.consumeStatementTerminator();\n    }\n    return body;\n  }\n\n  parseAssignment() {\n    const left = this.parseRescueExpression();\n    if (this.allowMultiAssign && this.check('OPERATOR', ',') && this.isAssignableNode(left)) {\n      const checkpoint = this.current;\n      try {\n        const targets = [this.ensureAssignable(left)];\n        while (this.match('OPERATOR', ',')) {\n          const target = this.parseRescueExpression();\n          targets.push(this.ensureAssignable(target));\n        }\n        this.consume('OPERATOR', '=', 'Expected = after multiple assignment');\n        const right = this.parseAssignment();\n        return {\n          type: 'MultiAssignmentExpression',\n          targets,\n          right\n        };\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          this.current = checkpoint;\n        } else {\n          throw error;\n        }\n      }\n    }\n    if (this.match('OPERATOR', '=') || this.matchAssignmentOperator()) {\n      const operator = this.previous();\n      const right = this.parseAssignment();\n      return {\n        type: 'AssignmentExpression',\n        operator: operator.value,\n        left: this.ensureAssignable(left),\n        right\n      };\n    }\n    return left;\n  }\n\n  parseRescueExpression() {\n    let expr = this.parseConditional();\n\n    if (!this.check('KEYWORD', 'rescue')) {\n      return expr;\n    }\n\n    const primary = expr;\n    this.advance(); // consume rescue\n    const rescueExpression = this.parseExpression();\n\n    const bodyBlock = this.wrapExpressionAsBlock(primary);\n    const rescueBlock = this.wrapExpressionAsBlock(rescueExpression);\n\n    return {\n      type: 'BeginRescueExpression',\n      body: bodyBlock,\n      rescues: [\n        {\n          type: 'RescueClause',\n          exceptions: [],\n          binding: null,\n          body: rescueBlock\n        }\n      ],\n      elseBody: null,\n      ensureBody: null,\n      inline: true\n    };\n  }\n\n  parseConditional() {\n    let expr = this.parseLogicalOr();\n    if (this.match('OPERATOR', '?')) {\n      const consequent = this.parseExpression();\n      this.consume('OPERATOR', ':', \"Expected ':' in conditional expression\");\n      const alternate = this.parseExpression();\n      expr = { type: 'ConditionalExpression', test: expr, consequent, alternate };\n    }\n    return expr;\n  }\n\n  matchAssignmentOperator() {\n    const operators = ['+=', '-=', '*=', '/=', '%=', '||=', '&&='];\n    for (const op of operators) {\n      if (this.match('OPERATOR', op)) return true;\n    }\n    return false;\n  }\n\n  ensureAssignable(node) {\n    if (!node) throw new SyntaxError('Invalid assignment target');\n    const valid = ['Identifier', 'InstanceVariable', 'ClassVariable', 'MemberExpression'];\n    if (valid.includes(node.type)) return node;\n    throw new SyntaxError('Invalid assignment target');\n  }\n\n  isAssignableNode(node) {\n    if (!node) return false;\n    const valid = ['Identifier', 'InstanceVariable', 'ClassVariable', 'MemberExpression'];\n    return valid.includes(node.type);\n  }\n\n  isIndexableExpression(node) {\n    if (!node) return false;\n    const valid = [\n      'Identifier',\n      'MemberExpression',\n      'OptionalMemberExpression',\n      'InstanceVariable',\n      'ClassVariable',\n      'SelfExpression'\n    ];\n    return valid.includes(node.type);\n  }\n\n  parseLogicalOr() {\n    let expr = this.parseLogicalAnd();\n    while (this.match('OPERATOR', '||')) {\n      const operator = this.previous().value;\n      const right = this.parseLogicalAnd();\n      expr = { type: 'LogicalExpression', operator, left: expr, right };\n    }\n    return expr;\n  }\n\n  parseLogicalAnd() {\n    let expr = this.parseEquality();\n    while (this.match('OPERATOR', '&&')) {\n      const operator = this.previous().value;\n      const right = this.parseEquality();\n      expr = { type: 'LogicalExpression', operator, left: expr, right };\n    }\n    return expr;\n  }\n\n  parseEquality() {\n    let expr = this.parseRange();\n    while (this.match('OPERATOR', '==') || this.match('OPERATOR', '!=')) {\n      const operator = this.previous().value;\n      const right = this.parseRange();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n    return expr;\n  }\n\n  parseRange() {\n    let expr = this.parseComparison();\n    if (this.match('OPERATOR', '..') || this.match('OPERATOR', '...')) {\n      const operator = this.previous().value;\n      const right = this.parseRange();\n      expr = {\n        type: 'RangeExpression',\n        start: expr,\n        end: right,\n        exclusive: operator === '...'\n      };\n    }\n    return expr;\n  }\n\n  parseComparison() {\n    let expr = this.parseTerm();\n    while (this.match('OPERATOR', '<') || this.match('OPERATOR', '>') ||\n      this.match('OPERATOR', '<=') || this.match('OPERATOR', '>=')) {\n      const operator = this.previous().value;\n      const right = this.parseTerm();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n    return expr;\n  }\n\n  parseTerm() {\n    let expr = this.parseFactor();\n    while (true) {\n      if (this.match('OPERATOR', '+') || this.match('OPERATOR', '-')) {\n        const operator = this.previous().value;\n        const right = this.parseFactor();\n        expr = { type: 'BinaryExpression', operator, left: expr, right };\n        continue;\n      }\n      if (this.match('OPERATOR', '<<')) {\n        const operator = this.previous().value;\n        const right = this.parseFactor();\n        expr = { type: 'BinaryExpression', operator, left: expr, right };\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  parseFactor() {\n    let expr = this.parseUnary();\n    while (this.match('OPERATOR', '*') || this.match('OPERATOR', '/') || this.match('OPERATOR', '%')) {\n      const operator = this.previous().value;\n      const right = this.parseUnary();\n      expr = { type: 'BinaryExpression', operator, left: expr, right };\n    }\n    return expr;\n  }\n\n  parseUnary() {\n    if (this.match('OPERATOR', '!') || this.match('OPERATOR', '-') || this.match('OPERATOR', '+')) {\n      const operator = this.previous().value;\n      const argument = this.parseUnary();\n      return { type: 'UnaryExpression', operator, argument };\n    }\n    if (this.match('OPERATOR', '&')) {\n      const expression = this.parseUnary();\n      if (expression.type === 'SymbolLiteral') {\n        return { type: 'ToProcExpression', argument: expression };\n      }\n      return { type: 'BlockPassExpression', expression };\n    }\n    return this.parseCall();\n  }\n\n  isKeywordArgumentStart() {\n    const current = this.peek();\n    const next = this.tokens[this.current + 1];\n    if (!current || !next) return false;\n    if (current.type !== 'IDENTIFIER') return false;\n    if (next.type !== 'OPERATOR' || next.value !== ':') return false;\n    return true;\n  }\n\n  parseKeywordArgumentGroup() {\n    const properties = [];\n    while (true) {\n      const keyToken = this.consumeIdentifier('Expected keyword argument name');\n      const keyNode = { type: 'Identifier', name: keyToken.value };\n      this.consume('OPERATOR', ':', \"Expected ':' after keyword argument name\");\n      this.skipNewlines();\n      const value = this.parseExpression();\n      properties.push({ key: keyNode, value });\n      if (!this.check('OPERATOR', ',')) break;\n      const next = this.tokens[this.current + 1];\n      const after = this.tokens[this.current + 2];\n      if (!(next && next.type === 'IDENTIFIER' && after && after.type === 'OPERATOR' && after.value === ':')) {\n        break;\n      }\n      this.advance(); // consume ',' and continue parsing more keyword pairs\n    }\n    return { type: 'HashExpression', properties, keyword: true };\n  }\n\n  parseCall() {\n    let expr = this.parsePrimary();\n\n    while (true) {\n      while (true) {\n        if (this.check('NEWLINE')) {\n          const next = this.tokens[this.current + 1];\n          if (next && next.type === 'OPERATOR') {\n            if (next.value === '.' || next.value === '&.') {\n              this.advance();\n              continue;\n            }\n          }\n          break;\n        }\n        if (this.match('OPERATOR', '(')) {\n          const args = [];\n          if (!this.check('OPERATOR', ')')) {\n            const parseArgument = () => {\n              if (this.match('OPERATOR', '...')) {\n                args.push({ type: 'ForwardingArguments' });\n                return;\n              }\n              if (this.isKeywordArgumentStart()) {\n                args.push(this.parseKeywordArgumentGroup());\n              } else {\n                const previous = this.allowMultiAssign;\n                this.allowMultiAssign = false;\n                args.push(this.parseExpression());\n                this.allowMultiAssign = previous;\n              }\n            };\n            parseArgument();\n            while (this.check('OPERATOR', ',')) {\n              this.advance();\n              parseArgument();\n            }\n          }\n          this.consume('OPERATOR', ')', 'Expected closing ) after arguments');\n          expr = { type: 'CallExpression', callee: expr, arguments: args };\n          continue;\n        }\n        if (this.match('OPERATOR', '&.')) {\n          const propertyToken = this.consumeIdentifier('Expected method name after &.');\n          expr = {\n            type: 'OptionalMemberExpression',\n            object: expr,\n            property: { type: 'Identifier', name: propertyToken.value },\n            computed: false\n          };\n          const nextToken = this.peek();\n          if (!(nextToken && nextToken.type === 'OPERATOR' && (nextToken.value === '(' || nextToken.value === '='))) {\n            expr = this.ensureCallExpression(expr);\n          }\n          continue;\n        }\n        if (this.match('OPERATOR', '.')) {\n          const propertyToken = this.consumeIdentifier('Expected property name after .');\n          expr = {\n            type: 'MemberExpression',\n            object: expr,\n            property: { type: 'Identifier', name: propertyToken.value },\n            computed: false\n          };\n          const nextToken = this.peek();\n          if (!(nextToken && nextToken.type === 'OPERATOR' && (nextToken.value === '(' || nextToken.value === '='))) {\n            expr = this.ensureCallExpression(expr);\n          }\n          continue;\n        }\n        if (this.match('OPERATOR', '[')) {\n          const index = this.parseExpression();\n          this.consume('OPERATOR', ']', 'Expected closing ]');\n          expr = {\n            type: 'MemberExpression',\n            object: expr,\n            property: index,\n            computed: true\n          };\n          continue;\n        }\n        if (this.canAttachBlock(expr) && (this.check('KEYWORD', 'do') || this.check('OPERATOR', '{'))) {\n          expr = this.attachBlock(expr);\n          continue;\n        }\n        break;\n      }\n\n      expr = this.wrapImplicitCall(expr);\n\n      if (this.canCommandCall(expr)) {\n        const args = [];\n        const parseArgument = () => {\n          if (this.match('OPERATOR', '...')) {\n            args.push({ type: 'ForwardingArguments' });\n            return;\n          }\n          if (this.isKeywordArgumentStart()) {\n            args.push(this.parseKeywordArgumentGroup());\n          } else {\n            const previous = this.allowMultiAssign;\n            this.allowMultiAssign = false;\n            args.push(this.parseExpression());\n            this.allowMultiAssign = previous;\n          }\n        };\n        parseArgument();\n        while (this.check('OPERATOR', ',')) {\n          this.advance();\n          parseArgument();\n        }\n        expr = { type: 'CallExpression', callee: expr, arguments: args };\n        continue;\n      }\n\n      break;\n    }\n\n    return expr;\n  }\n\n\n  wrapImplicitCall(expr) {\n    if (!expr) return expr;\n    if (!['MemberExpression', 'OptionalMemberExpression'].includes(expr.type)) {\n      return expr;\n    }\n    if (expr.type === 'MemberExpression' && expr.computed) {\n      return expr;\n    }\n    if (expr.type === 'OptionalMemberExpression' && expr.computed) {\n      return expr;\n    }\n    if (!this.shouldImplicitCall()) return expr;\n    return { type: 'CallExpression', callee: expr, arguments: [] };\n  }\n\n  ensureCallExpression(expr) {\n    if (expr.type === 'CallExpression') return expr;\n    return { type: 'CallExpression', callee: expr, arguments: [] };\n  }\n\n  canAttachBlock(expr) {\n    if (!expr) return false;\n    return ['Identifier', 'CallExpression', 'MemberExpression', 'OptionalMemberExpression'].includes(expr.type);\n  }\n\n  attachBlock(expr) {\n    let current = expr;\n    while (true) {\n      if (this.check('KEYWORD', 'do') && this.canAttachBlock(current)) {\n        this.advance();\n        current = this.ensureCallExpression(current);\n        const block = this.parseDoBlock();\n        current.block = block;\n        continue;\n      }\n      if (this.check('OPERATOR', '{') && this.canAttachBlock(current)) {\n        const block = this.parseBraceBlock();\n        current = this.ensureCallExpression(current);\n        current.block = block;\n        continue;\n      }\n      break;\n    }\n    return current;\n  }\n\n  parseDoBlock() {\n    const params = this.parseBlockParameters();\n    this.consumeStatementTerminator();\n    const body = this.parseBlock(['end']);\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close block\");\n    return { params, body: { type: 'BlockStatement', body } };\n  }\n\n  parseBlockParameters() {\n    const params = [];\n    if (!this.match('OPERATOR', '|')) return params;\n    if (!this.check('OPERATOR', '|')) {\n      do {\n        const token = this.consume('IDENTIFIER', undefined, 'Expected block parameter');\n        params.push({ type: 'Identifier', name: token.value });\n      } while (this.match('OPERATOR', ','));\n    }\n    this.consume('OPERATOR', '|', \"Expected closing | for block parameters\");\n    return params;\n  }\n\n  shouldImplicitCall() {\n    const token = this.peek();\n    if (!token) return true;\n    if (token.type === 'NEWLINE' || token.type === 'EOF') return true;\n    if (token.type === 'KEYWORD' && ['end', 'else', 'elsif', 'when'].includes(token.value)) return true;\n    if (token.type === 'OPERATOR' && [')', ']', '}', ','].includes(token.value)) return true;\n    return false;\n  }\n\n  parsePrimary() {\n    if (this.match('NUMBER')) {\n      return { type: 'NumericLiteral', value: Number(this.previous().value) };\n    }\n    if (this.match('REGEX')) {\n      const token = this.previous();\n      return { type: 'RegExpLiteral', pattern: token.value.pattern, flags: token.value.flags };\n    }\n    if (this.match('STRING')) {\n      return { type: 'StringLiteral', value: this.previous().value };\n    }\n    if (this.match('PERCENT_STRING_ARRAY')) {\n      const token = this.previous();\n      return {\n        type: 'ArrayExpression',\n        elements: token.value.values.map(value => ({ type: 'StringLiteral', value }))\n      };\n    }\n    if (this.match('KEYWORD', 'true')) {\n      return { type: 'BooleanLiteral', value: true };\n    }\n    if (this.match('KEYWORD', 'false')) {\n      return { type: 'BooleanLiteral', value: false };\n    }\n    if (this.match('KEYWORD', 'nil')) {\n      return { type: 'NullLiteral', value: null };\n    }\n    if (this.match('KEYWORD', 'self')) {\n      return { type: 'SelfExpression' };\n    }\n    if (this.match('KEYWORD', 'super')) {\n      const args = [];\n      if (this.match('OPERATOR', '(')) {\n        if (!this.check('OPERATOR', ')')) {\n          do {\n            args.push(this.parseExpression());\n          } while (this.match('OPERATOR', ','));\n        }\n        this.consume('OPERATOR', ')', 'Expected closing ) after super arguments');\n      } else if (!this.isTerminator(this.peek())) {\n        args.push(this.parseExpression());\n        while (this.match('OPERATOR', ',')) {\n          args.push(this.parseExpression());\n        }\n      }\n      return { type: 'SuperCall', arguments: args };\n    }\n    if (this.match('KEYWORD', 'begin')) {\n      return this.parseBeginExpression();\n    }\n    if (this.match('OPERATOR', ':')) {\n      const token = this.consumeSymbolToken('Expected symbol name after :');\n      return { type: 'SymbolLiteral', name: token.value };\n    }\n    if (this.match('IDENTIFIER')) {\n      const token = this.previous();\n      if (token.value.startsWith('@@')) {\n        return { type: 'ClassVariable', name: token.value.slice(2) };\n      }\n      if (token.value.startsWith('@')) {\n        return { type: 'InstanceVariable', name: token.value.slice(1) };\n      }\n      const name = token.value;\n      if (name === 'block_given?') {\n        const nextToken = this.peek();\n        if (!(nextToken && nextToken.type === 'OPERATOR' && nextToken.value === '(')) {\n          return {\n            type: 'CallExpression',\n            callee: { type: 'Identifier', name },\n            arguments: []\n          };\n        }\n      }\n      return { type: 'Identifier', name };\n    }\n    if (this.match('OPERATOR', '(')) {\n      const expr = this.parseExpression();\n      this.consume('OPERATOR', ')', 'Expected closing )');\n      return expr;\n    }\n    if (this.match('OPERATOR', '[')) {\n      const elements = [];\n      this.skipNewlines();\n      if (!this.check('OPERATOR', ']')) {\n        while (true) {\n          elements.push(this.parseExpression());\n          this.skipNewlines();\n          if (!this.match('OPERATOR', ',')) break;\n          this.skipNewlines();\n        }\n      }\n      this.consume('OPERATOR', ']', 'Expected closing ]');\n      return { type: 'ArrayExpression', elements };\n    }\n    if (this.match('OPERATOR', '{')) {\n      const properties = [];\n      if (!this.check('OPERATOR', '}')) {\n        do {\n          const keyToken = this.consumeKey();\n          let value;\n          if (this.match('OPERATOR', '=>')) {\n            value = this.parseExpression();\n          } else if (this.match('OPERATOR', ':')) {\n            value = this.parseExpression();\n          } else {\n            throw new SyntaxError(\"Expected '=>' or ':' in hash\");\n          }\n          properties.push({ key: keyToken, value });\n        } while (this.match('OPERATOR', ','));\n      }\n      this.consume('OPERATOR', '}', 'Expected closing }');\n      return { type: 'HashExpression', properties };\n    }\n\n    if (this.match('OPERATOR', '->')) {\n      return this.parseLambda();\n    }\n\n    if (this.match('KEYWORD', 'yield')) {\n      const args = [];\n      const previous = this.allowMultiAssign;\n      this.allowMultiAssign = false;\n      if (this.match('OPERATOR', '(')) {\n        if (!this.check('OPERATOR', ')')) {\n          const parseArgument = () => {\n            args.push(this.parseExpression());\n          };\n          parseArgument();\n          while (this.check('OPERATOR', ',')) {\n            this.advance();\n            parseArgument();\n          }\n        }\n        this.consume('OPERATOR', ')', 'Expected closing ) after yield arguments');\n      } else if (!this.isTerminator(this.peek())) {\n        args.push(this.parseExpression());\n        while (this.check('OPERATOR', ',')) {\n          this.advance();\n          args.push(this.parseExpression());\n        }\n      }\n      this.allowMultiAssign = previous;\n      return { type: 'YieldExpression', arguments: args };\n    }\n\n    throw new SyntaxError(`Unexpected token ${this.peek().type} ${this.peek().value ?? ''}`);\n  }\n\n  consumeKey() {\n    if (this.match('STRING')) {\n      return { type: 'StringLiteral', value: this.previous().value };\n    }\n    if (this.match('IDENTIFIER')) {\n      return { type: 'Identifier', name: this.previous().value };\n    }\n    if (this.match('OPERATOR', ':')) {\n      const token = this.consumeSymbolToken('Expected symbol name');\n      return { type: 'SymbolLiteral', name: token.value };\n    }\n    throw new SyntaxError('Invalid hash key');\n  }\n\n  consumeSymbolToken(message) {\n    if (this.check('IDENTIFIER')) return this.advance();\n    if (this.check('KEYWORD')) return this.advance();\n    if (this.check('OPERATOR')) return this.advance();\n    throw new SyntaxError(message);\n  }\n\n  parseExpression() {\n    return this.parseAssignment();\n  }\n\n  consume(type, value, message) {\n    if (message === undefined) {\n      message = value;\n      value = undefined;\n    }\n    if (this.check(type, value)) return this.advance();\n    throw new SyntaxError(message);\n  }\n\n  consumeIdentifier(message) {\n    if (this.check('IDENTIFIER')) return this.advance();\n    if (this.check('KEYWORD')) return this.advance();\n    throw new SyntaxError(message);\n  }\n\n  parseBraceBlock(openConsumed = false) {\n    if (!openConsumed) {\n      this.consume('OPERATOR', '{', \"Expected '{' to start block\");\n    }\n    const params = this.parseBlockParameters();\n    this.consumeStatementTerminator();\n    const body = [];\n    while (!this.check('EOF') && !this.check('OPERATOR', '}')) {\n      this.skipNewlines();\n      if (this.check('OPERATOR', '}')) break;\n      body.push(this.parseStatement());\n      this.consumeStatementTerminator();\n    }\n    this.consume('OPERATOR', '}', \"Expected '}' to close block\");\n    return { params, body: { type: 'BlockStatement', body } };\n  }\n\n  parseLambda() {\n    const params = [];\n    if (this.match('OPERATOR', '(')) {\n      if (!this.check('OPERATOR', ')')) {\n        do {\n          if (this.match('OPERATOR', '*')) {\n            const rest = this.consumeIdentifier('Expected rest parameter name');\n            params.push({ type: 'RestParameter', name: rest.value });\n            continue;\n          }\n          const param = this.consumeIdentifier('Expected parameter name');\n          params.push({ type: 'Identifier', name: param.value });\n        } while (this.match('OPERATOR', ','));\n      }\n      this.consume('OPERATOR', ')', 'Expected closing ) after lambda parameters');\n    }\n\n    let block;\n    if (this.match('OPERATOR', '{')) {\n      block = this.parseBraceBlock(true);\n    } else if (this.match('KEYWORD', 'do')) {\n      block = this.parseDoBlock();\n    } else {\n      throw new SyntaxError('Expected block after lambda');\n    }\n\n    const lambdaParams = params.length ? params : block.params;\n\n    return {\n      type: 'LambdaExpression',\n      params: lambdaParams,\n      body: block.body\n    };\n  }\n\n  wrapExpressionAsBlock(expression) {\n    return {\n      type: 'BlockStatement',\n      body: [\n        {\n          type: 'ExpressionStatement',\n          expression\n        }\n      ]\n    };\n  }\n\n  parseBeginExpression() {\n    this.consumeStatementTerminator();\n    const bodyStatements = this.parseBlock(['rescue', 'else', 'ensure', 'end']);\n    const bodyBlock = { type: 'BlockStatement', body: bodyStatements };\n\n    const rescues = [];\n    while (this.match('KEYWORD', 'rescue')) {\n      rescues.push(this.parseRescueClause());\n    }\n\n    let elseBody = null;\n    if (this.match('KEYWORD', 'else')) {\n      this.consumeStatementTerminator();\n      const elseStatements = this.parseBlock(['ensure', 'end']);\n      elseBody = { type: 'BlockStatement', body: elseStatements };\n    }\n\n    let ensureBody = null;\n    if (this.match('KEYWORD', 'ensure')) {\n      this.consumeStatementTerminator();\n      const ensureStatements = this.parseBlock(['end']);\n      ensureBody = { type: 'BlockStatement', body: ensureStatements };\n    }\n\n    this.consume('KEYWORD', 'end', \"Expected 'end' to close begin/rescue block\");\n\n    return {\n      type: 'BeginRescueExpression',\n      body: bodyBlock,\n      rescues,\n      elseBody,\n      ensureBody,\n      inline: false\n    };\n  }\n\n  parseRescueClause() {\n    const exceptions = [];\n\n    if (!this.isRescueClauseTerminator(this.peek())) {\n      do {\n        exceptions.push(this.parseExpression());\n      } while (this.match('OPERATOR', ','));\n    }\n\n    let binding = null;\n    if (this.match('OPERATOR', '=>')) {\n      const identifier = this.consumeIdentifier('Expected rescue variable name');\n      binding = { type: 'Identifier', name: identifier.value };\n    }\n\n    this.consumeStatementTerminator();\n    const bodyStatements = this.parseBlock(['rescue', 'else', 'ensure', 'end']);\n    return {\n      type: 'RescueClause',\n      exceptions,\n      binding,\n      body: { type: 'BlockStatement', body: bodyStatements }\n    };\n  }\n\n  isRescueClauseTerminator(token) {\n    if (!token) return true;\n    if (token.type === 'NEWLINE' || token.type === 'EOF') return true;\n    if (token.type === 'OPERATOR' && token.value === '=>') return true;\n    if (token.type === 'KEYWORD' && ['do', 'then'].includes(token.value)) return true;\n    return false;\n  }\n\n  containsYield(node) {\n    if (!node || typeof node !== 'object') return false;\n    switch (node.type) {\n      case 'YieldExpression':\n        return true;\n      case 'BlockStatement':\n        return node.body.some(child => this.containsYield(child));\n      case 'ExpressionStatement':\n        return this.containsYield(node.expression);\n      case 'IfStatement':\n        return this.containsYield(node.test) ||\n          (node.consequent && this.containsYield(node.consequent)) ||\n          (node.alternate && this.containsYield(node.alternate));\n      case 'AssignmentExpression':\n        return this.containsYield(node.left) || this.containsYield(node.right);\n      case 'CallExpression':\n        if (this.containsYield(node.callee)) return true;\n        if (node.arguments.some(arg => this.containsYield(arg))) return true;\n        if (node.block) return this.containsYield(node.block.body);\n        return false;\n      case 'MemberExpression':\n        return this.containsYield(node.object) || (node.computed && this.containsYield(node.property));\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        return this.containsYield(node.left) || this.containsYield(node.right);\n      case 'UnaryExpression':\n        return this.containsYield(node.argument);\n      case 'ConditionalExpression':\n        return this.containsYield(node.test) || this.containsYield(node.consequent) || this.containsYield(node.alternate);\n      case 'CaseStatement':\n        if (node.test && this.containsYield(node.test)) return true;\n        for (const clause of node.clauses) {\n          if (clause.type === 'WhenClause' && clause.tests) {\n            if (clause.tests.some(test => this.containsYield(test))) return true;\n          }\n          if (this.containsYield(clause.body)) return true;\n        }\n        return node.alternate ? this.containsYield(node.alternate) : false;\n      case 'BeginRescueExpression':\n        if (this.containsYield(node.body)) return true;\n        if (node.rescues) {\n          for (const clause of node.rescues) {\n            if (clause.exceptions && clause.exceptions.some(exception => this.containsYield(exception))) {\n              return true;\n            }\n            if (this.containsYield(clause.body)) return true;\n          }\n        }\n        if (node.elseBody && this.containsYield(node.elseBody)) return true;\n        if (node.ensureBody && this.containsYield(node.ensureBody)) return true;\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  peekNextIs(value) {\n    const token = this.tokens[this.current + 1];\n    if (!token) return false;\n    if (typeof value === 'string') {\n      return token.type === 'OPERATOR' && token.value === value;\n    }\n    return token.type === value;\n  }\n\n  match(type, value) {\n    if (this.check(type, value)) {\n      this.advance();\n      return true;\n    }\n    return false;\n  }\n\n  check(type, value) {\n    if (this.isAtEnd()) return type === 'EOF';\n    const token = this.peek();\n    if (token.type !== type) return false;\n    if (value === undefined) return true;\n    return token.value === value;\n  }\n\n  checkAny(keywords) {\n    if (!Array.isArray(keywords)) return false;\n    for (const word of keywords) {\n      if (this.check('KEYWORD', word)) return true;\n    }\n    return false;\n  }\n\n  advance() {\n    if (!this.isAtEnd()) this.current += 1;\n    return this.previous();\n  }\n\n  isAtEnd() {\n    return this.peek().type === 'EOF';\n  }\n\n  peek() {\n    return this.tokens[this.current];\n  }\n\n  previous() {\n    return this.tokens[this.current - 1];\n  }\n\n  skipNewlines() {\n    while (this.match('NEWLINE')) {}\n  }\n\n  consumeStatementTerminator() {\n    let consumed = false;\n    while (true) {\n      if (this.match('NEWLINE')) {\n        consumed = true;\n        continue;\n      }\n      if (this.match('OPERATOR', ';')) {\n        consumed = true;\n        continue;\n      }\n      break;\n    }\n    return consumed;\n  }\n\n  consumeOptionalThen() {\n    this.match('KEYWORD', 'then');\n  }\n\n  isTerminator(token) {\n    if (!token) return true;\n    if (token.type === 'NEWLINE') return true;\n    if (token.type === 'EOF') return true;\n    if (token.type === 'KEYWORD' && token.value === 'end') return true;\n    return false;\n  }\n\n  canCommandCall(expr) {\n    if (!expr) return false;\n    if (!['Identifier', 'MemberExpression', 'CallExpression', 'OptionalMemberExpression'].includes(expr.type)) return false;\n    const token = this.peek();\n    if (!token) return false;\n    if (token.type === 'NEWLINE' || token.type === 'EOF') return false;\n    if (token.type === 'KEYWORD' && ['end', 'else', 'elsif', 'when'].includes(token.value)) return false;\n    if (token.type === 'OPERATOR' && [')', '}', ']', '=', '+=', '-=', '*=', '/=', '%=', '=>'].includes(token.value)) return false;\n    if (!this.isExpressionStart(token)) return false;\n    return true;\n  }\n\n  isExpressionStart(token) {\n    if (!token) return false;\n    if (token.type === 'IDENTIFIER') return true;\n    if (token.type === 'NUMBER' || token.type === 'STRING') return true;\n    if (token.type === 'PERCENT_STRING_ARRAY') return true;\n    if (token.type === 'KEYWORD' && ['true', 'false', 'nil', 'self'].includes(token.value)) return true;\n    if (token.type === 'OPERATOR' && ['(', '[', ':', '!'].includes(token.value)) return true;\n    return false;\n  }\n}\n\nmodule.exports = { Parser };\n", "const { Tokenizer } = require('./tokenizer');\nconst { Parser } = require('./parser');\n\nclass Emitter {\n  constructor(options = {}) {\n    this.mode = options.mode === 'fast' ? 'fast' : 'strict';\n    this.fastMode = this.mode === 'fast';\n    this.indentSize = options.indent ?? 2;\n    this.indentLevel = 0;\n    this.scopeInfo = new Map();\n    this.runtimeHelpers = new Set();\n    this.uniqueIdCounter = 0;\n    this.injectedRequires = new Set();\n    this.reservedWords = new Set([\n      'enum', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete',\n      'do', 'else', 'export', 'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof',\n      'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with',\n      'yield', 'let', 'static', 'implements', 'interface', 'package', 'private', 'protected', 'public',\n      'null', 'true', 'false', 'arguments'\n    ]);\n  }\n\n  emit(program) {\n    this.collectProgram(program);\n    return this.emitProgram(program);\n  }\n\n  emitProgram(node) {\n    const scope = this.scopeInfo.get(node);\n    const hoistedLines = [];\n    if (scope && scope.hoisted.size) {\n      for (const name of [...scope.hoisted].sort()) {\n        const safeName = this.getRenamedName(scope, name);\n        hoistedLines.push(this.indent() + `let ${safeName};`);\n      }\n    }\n\n    const bodyLines = [];\n    for (const statement of node.body) {\n      const code = this.emitStatement(statement, { scopeNode: node, scopeStack: [node] });\n      if (code) bodyLines.push(code);\n    }\n\n    const helperLines = this.buildRuntimePrelude();\n\n    if (!helperLines.length) {\n      if (hoistedLines.length && bodyLines.length) {\n        return [...hoistedLines, ...bodyLines].join('\\n');\n      }\n      if (hoistedLines.length) return hoistedLines.join('\\n');\n      if (bodyLines.length) return bodyLines.join('\\n');\n      return '';\n    }\n\n    const segments = [];\n    if (hoistedLines.length) segments.push(hoistedLines);\n    segments.push(helperLines);\n    if (bodyLines.length) segments.push(bodyLines);\n\n    const lines = [];\n    segments.forEach((segment, index) => {\n      if (index > 0) lines.push('');\n      lines.push(...segment);\n    });\n\n    return lines.join('\\n');\n  }\n\n  requireRuntime(helperName) {\n    this.runtimeHelpers.add(helperName);\n  }\n\n  buildRuntimePrelude() {\n    if (!this.runtimeHelpers.size) return [];\n    const lines = [];\n\n    if (this.runtimeHelpers.has('fileConstant')) {\n      if (lines.length) lines.push('');\n      lines.push('const __FILE__ = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && typeof globalThis.__FILE__ !== \"undefined\") {');\n      lines.push('    return globalThis.__FILE__;');\n      lines.push('  }');\n      lines.push('  if (typeof __rubySourceFile !== \"undefined\") return __rubySourceFile;');\n      lines.push('  return \"unknown.rb\";');\n      lines.push('})();');\n      lines.push('if (typeof globalThis !== \"undefined\") { globalThis.__FILE__ = __FILE__; }');\n    }\n\n    if (this.runtimeHelpers.has('bindingHelper')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyBinding = () => ({ locals: {} });');\n    }\n\n    if (this.runtimeHelpers.has('print')) {\n      lines.push('const __rubyPrint = (...chunks) => {');\n      lines.push('  const text = chunks.map(chunk => String(chunk ?? \"\")).join(\"\");');\n      lines.push('  if (typeof process !== \"undefined\" && process.stdout && process.stdout.write) {');\n      lines.push('    process.stdout.write(text);');\n      lines.push('  } else if (typeof console !== \"undefined\" && console.log) {');\n      lines.push('    console.log(text);');\n      lines.push('  }');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('gets')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyGets = (...promptParts) => {');\n      lines.push('  const message = promptParts.length ? promptParts.map(part => String(part ?? \"\")).join(\"\") : \"\";');\n      lines.push('  if (typeof prompt === \"function\") {');\n      lines.push('    const result = prompt(message);');\n      lines.push('    return result == null ? \"\" : result;');\n      lines.push('  }');\n      lines.push('  console.warn(\"gets() is not supported in this environment.\");');\n      lines.push('  return \"\";');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('putsGlobal')) {\n      if (lines.length) lines.push('');\n      lines.push('if (typeof globalThis !== \"undefined\" && !globalThis.puts) {');\n      lines.push('  globalThis.puts = (...values) => {');\n      lines.push('    if (typeof console !== \"undefined\" && console.log) {');\n      lines.push('      console.log(...values);');\n      lines.push('    }');\n      lines.push('  };');\n      lines.push('}');\n    }\n\n    if (this.runtimeHelpers.has('className')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyClassName = (value) => {');\n      lines.push('  if (value === null || value === undefined) return \"NilClass\";');\n      const typeLogic = [\n        '  if (value === true) return \"TrueClass\";',\n        '  if (value === false) return \"FalseClass\";',\n        '  if (typeof value === \"string\") return \"String\";',\n        '  if (typeof value === \"symbol\") return \"Symbol\";',\n        '  if (typeof value === \"number\") return Number.isFinite(value) && Number.isInteger(value) ? \"Integer\" : \"Float\";',\n        '  if (typeof value === \"bigint\") return \"Integer\";',\n        '  if (Array.isArray(value)) return \"Array\";',\n        '  if (value instanceof Map) return \"Hash\";',\n        '  if (value instanceof Set) return \"Set\";',\n        '  if (typeof value === \"function\") return \"Proc\";',\n        '  if (typeof value === \"object\") {',\n        '    const proto = Object.getPrototypeOf(value);',\n        '    if (!proto || proto === Object.prototype) return \"Hash\";',\n        '    if (value.constructor && typeof value.constructor.name === \"string\" && value.constructor.name.length) {',\n        '      return value.constructor.name;',\n        '    }',\n        '    return \"Object\";',\n        '  }',\n        '  return typeof value;',\n      ];\n      lines.push(...typeLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('jsBridge')) {\n      if (lines.length) lines.push('');\n      lines.push('const JS = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && globalThis.JS) return globalThis.JS;');\n      const bridgeLogic = [\n        '  const bridge = {',\n        '    global() {',\n        '      if (typeof globalThis !== \"undefined\") return globalThis;',\n        '      if (typeof window !== \"undefined\") return window;',\n        '      if (typeof self !== \"undefined\") return self;',\n        '      return {};',\n        '    },',\n        '    eval(code) {',\n        '      const source = String(code ?? \"\");',\n        '      return (function(execCode) { return eval(execCode); })(source);',\n        '    },',\n        '    get(path) {',\n        '      const root = this.global();',\n        '      if (!path) return root;',\n        '      return String(path).split(\".\").reduce((value, key) => (value == null ? value : value[key]), root);',\n        '    },',\n        '    set(path, value) {',\n        '      const root = this.global();',\n        '      if (!path) return value;',\n      ];\n      lines.push(...bridgeLogic);\n      const bridgeTail = [\n        '      const parts = String(path).split(\".\");',\n        '      const last = parts.pop();',\n        '      const target = parts.length ? parts.reduce((obj, key) => (obj == null ? obj : obj[key]), root) : root;',\n        '      if (target != null && last) {',\n        '        target[last] = value;',\n        '      }',\n        '      return value;',\n        '    }',\n        '  };',\n        '  if (typeof globalThis !== \"undefined\") globalThis.JS = bridge;',\n        '  return bridge;',\n        '})();'\n      ];\n      lines.push(...bridgeTail);\n    }\n\n    if (this.runtimeHelpers.has('ivarName')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyIvarName = (name) => {');\n      lines.push('  const str = String(name ?? \"\");');\n      lines.push('  const clean = str.startsWith(\"@\") ? str.slice(1) : str;');\n      lines.push('  return \"__\" + clean;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('strip')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyStrip = (value) => String(value ?? \"\").trim();');\n    }\n\n    if (this.runtimeHelpers.has('split')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubySplit = (value) => String(value ?? \"\").split(/\\\\s+/);');\n    }\n\n    if (this.runtimeHelpers.has('reverseString')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyReverse = (value) => String(value ?? \"\").split(\"\").reverse().join(\"\");');\n    }\n\n    if (this.runtimeHelpers.has('capitalize')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyCapitalize = (value) => {');\n      lines.push('  const str = String(value ?? \"\");');\n      lines.push('  if (!str.length) return str;');\n      lines.push('  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('upcase')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyUpcase = (value) => String(value ?? \"\").toUpperCase();');\n    }\n\n    if (this.runtimeHelpers.has('downcase')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyDowncase = (value) => String(value ?? \"\").toLowerCase();');\n    }\n\n    if (this.runtimeHelpers.has('swapcase')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubySwapcase = (value) => {');\n      lines.push('  const str = String(value ?? \"\");');\n      lines.push('  let result = \"\";');\n      lines.push('  for (let index = 0; index < str.length; index += 1) {');\n      lines.push('    const ch = str[index];');\n      lines.push('    const upper = ch.toUpperCase();');\n      lines.push('    const lower = ch.toLowerCase();');\n      lines.push('    if (ch === upper && ch !== lower) {');\n      lines.push('      result += lower;');\n      lines.push('    } else if (ch === lower && ch !== upper) {');\n      lines.push('      result += upper;');\n      lines.push('    } else {');\n      lines.push('      result += ch;');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('capitalizeBang')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyCapitalizeBang = (value) => __rubyCapitalize(value);');\n    }\n\n    if (this.runtimeHelpers.has('reverseBang')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyReverseBang = (value) => {');\n      lines.push('  const str = String(value ?? \"\");');\n      lines.push('  return str.split(\"\").reverse().join(\"\");');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('upcaseBang')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyUpcaseBang = (value) => String(value ?? \"\").toUpperCase();');\n    }\n\n    if (this.runtimeHelpers.has('downcaseBang')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyDowncaseBang = (value) => String(value ?? \"\").toLowerCase();');\n    }\n\n    if (this.runtimeHelpers.has('stripBang')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyStripBang = (value) => __rubyStrip(value);');\n    }\n\n    if (this.runtimeHelpers.has('swapcaseBang')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubySwapcaseBang = (value) => __rubySwapcase(value);');\n    }\n\n    if (this.runtimeHelpers.has('stringAssign')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyStringAssign = (source, key, value) => {');\n      lines.push('  const original = String(source ?? \"\");');\n      const stringAssignLogic = [\n        '  const replacement = value == null ? \"\" : String(value);',\n        '  if (typeof key === \"number\" || typeof key === \"bigint\") {',\n        '    const index = Number(key);',\n        '    if (!Number.isInteger(index)) return original;',\n        '    const length = original.length;',\n        '    const normalized = index < 0 ? length + index : index;',\n        '    if (normalized < 0 || normalized > length) return original;',\n        '    if (normalized === length) return original + replacement;',\n        '    return original.slice(0, normalized) + replacement + original.slice(normalized + 1);',\n        '  }',\n        '  if (key instanceof RegExp) {',\n        '    const flags = key.flags.replace(/g/g, \"\");',\n        '    const regex = new RegExp(key.source, flags);',\n        '    return original.replace(regex, replacement);',\n        '  }',\n        '  const needle = key == null ? \"\" : String(key);',\n        '  if (!needle.length) return original;',\n        '  const position = original.indexOf(needle);',\n        '  if (position === -1) return original;',\n        '  return original.slice(0, position) + replacement + original.slice(position + needle.length);'\n      ];\n      lines.push(...stringAssignLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('ljust')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyLjust = (value, width, padding) => {');\n      lines.push('  const str = String(value ?? \"\");');\n      lines.push('  const target = Number(width);');\n      lines.push('  if (!Number.isFinite(target) || target <= str.length) return str;');\n      lines.push('  const pad = padding === undefined ? \" \" : String(padding);');\n      lines.push('  if (!pad.length) return str;');\n      lines.push('  let result = str;');\n      lines.push('  while (result.length < target) {');\n      lines.push('    const remaining = target - result.length;');\n      lines.push('    result += pad.repeat(Math.ceil(remaining / pad.length)).slice(0, remaining);');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('rjust')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyRjust = (value, width, padding) => {');\n      lines.push('  const str = String(value ?? \"\");');\n      lines.push('  const target = Number(width);');\n      lines.push('  if (!Number.isFinite(target) || target <= str.length) return str;');\n      lines.push('  const pad = padding === undefined ? \" \" : String(padding);');\n      lines.push('  if (!pad.length) return str;');\n      lines.push('  let result = str;');\n      lines.push('  while (result.length < target) {');\n      lines.push('    const remaining = target - result.length;');\n      lines.push('    const chunk = pad.repeat(Math.ceil(remaining / pad.length)).slice(0, remaining);');\n      lines.push('    result = chunk + result;');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('chars')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyChars = (value) => Array.from(String(value ?? \"\"));');\n    }\n\n    if (this.runtimeHelpers.has('gsub')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyGsub = (value, pattern, replacement, block) => {');\n      lines.push('  const source = String(value ?? \"\");');\n      lines.push('  const buildRegex = (input) => {');\n      const gsubLogic = [\n        '    if (input instanceof RegExp) {',\n        '      const flags = input.flags.includes(\"g\") ? input.flags : input.flags + \"g\";',\n        '      return new RegExp(input.source, flags);',\n        '    }',\n        '    const escaped = String(input ?? \"\").replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, \"\\\\\\\\$&\");',\n        '    return new RegExp(escaped, \"g\");'\n      ];\n      lines.push(...gsubLogic);\n      lines.push('  };');\n      lines.push('  const regex = buildRegex(pattern);');\n      lines.push('  if (typeof block === \"function\") {');\n      lines.push('    return source.replace(regex, (...matchParts) => {');\n      lines.push('      const captures = matchParts.slice(0, -2);');\n      lines.push('      return block(...captures);');\n      lines.push('    });');\n      lines.push('  }');\n      lines.push('  const replacementValue = replacement === undefined ? \"\" : String(replacement);');\n      lines.push('  return source.replace(regex, replacementValue);');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('collectionInclude')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyCollectionInclude = (collection, item) => {');\n      lines.push('  if (Array.isArray(collection)) {');\n      lines.push('    for (let index = 0; index < collection.length; index += 1) {');\n      lines.push('      if (collection[index] === item) return true;');\n      lines.push('    }');\n      lines.push('    return false;');\n      lines.push('  }');\n      lines.push('  if (collection == null) return false;');\n      lines.push('  const str = String(collection);');\n      lines.push('  return str.includes(String(item));');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('minus')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyMinus = (left, right) => {');\n      lines.push('  if (Array.isArray(left)) {');\n      lines.push('    const rightValues = Array.isArray(right) ? right : [right];');\n      lines.push('    return left.filter((item) => rightValues.every((other) => other !== item));');\n      lines.push('  }');\n      lines.push('  const leftNumber = Number(left);');\n      lines.push('  const rightNumber = Number(right);');\n      lines.push('  if (!Number.isNaN(leftNumber) && !Number.isNaN(rightNumber)) {');\n      lines.push('    return leftNumber - rightNumber;');\n      lines.push('  }');\n      lines.push('  return left - right;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('times')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyTimes = (value, block) => {');\n      lines.push('  const numeric = Number(value);');\n      const timesLogic = [\n        '  const count = Number.isFinite(numeric) ? Math.max(0, Math.floor(numeric)) : 0;',\n        '  if (typeof block !== \"function\") {',\n        '    return Array.from({ length: count }, (_, index) => index);',\n        '  }',\n        '  for (let index = 0; index < count; index += 1) {',\n        '    block(index);',\n        '  }',\n        '  return value;'\n      ];\n      lines.push(...timesLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('upto')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyUpto = (value, limit, block) => {');\n      const uptoLogic = [\n        '  const start = Number(value);',\n        '  const end = Number(limit);',\n        '  if (!Number.isFinite(start) || !Number.isFinite(end)) {',\n        '    return typeof block === \"function\" ? value : [];',\n        '  }',\n        '  const from = Math.floor(start);',\n        '  const to = Math.floor(end);',\n        '  if (typeof block !== \"function\") {',\n        '    const result = [];',\n        '    for (let current = from; current <= to; current += 1) {',\n        '      result.push(current);',\n        '    }',\n        '    return result;',\n        '  }',\n        '  for (let current = from; current <= to; current += 1) {',\n        '    block(current);',\n        '  }',\n        '  return value;'\n      ];\n      lines.push(...uptoLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('downto')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyDownto = (value, limit, block) => {');\n      const downtoLogic = [\n        '  const start = Number(value);',\n        '  const end = Number(limit);',\n        '  if (!Number.isFinite(start) || !Number.isFinite(end)) {',\n        '    return typeof block === \"function\" ? value : [];',\n        '  }',\n        '  const from = Math.floor(start);',\n        '  const to = Math.floor(end);',\n        '  if (typeof block !== \"function\") {',\n        '    const result = [];',\n        '    for (let current = from; current >= to; current -= 1) {',\n        '      result.push(current);',\n        '    }',\n        '    return result;',\n        '  }',\n        '  for (let current = from; current >= to; current -= 1) {',\n        '    block(current);',\n        '  }',\n        '  return value;'\n      ];\n      lines.push(...downtoLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arrayPush')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyArrayPush = (target, ...values) => {');\n      lines.push('  if (Array.isArray(target)) {');\n      lines.push('    target.push(...values);');\n      lines.push('    return target;');\n      lines.push('  }');\n      lines.push('  if (target && typeof target.push === \"function\") {');\n      lines.push('    target.push(...values);');\n      lines.push('    return target;');\n      lines.push('  }');\n      lines.push('  return target;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arrayReject')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyReject = (collection, block) => {');\n      lines.push('  if (!Array.isArray(collection)) return [];');\n      lines.push('  if (typeof block !== \"function\") return collection.slice();');\n      lines.push('  const result = [];');\n      lines.push('  for (let index = 0; index < collection.length; index += 1) {');\n      lines.push('    if (!block(collection[index], index)) {');\n      lines.push('      result.push(collection[index]);');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arrayShuffle')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyShuffle = (collection) => {');\n      lines.push('  if (!Array.isArray(collection)) return [];');\n      lines.push('  const result = collection.slice();');\n      lines.push('  for (let index = result.length - 1; index > 0; index -= 1) {');\n      lines.push('    const swapIndex = Math.floor(Math.random() * (index + 1));');\n      lines.push('    const temp = result[index];');\n      lines.push('    result[index] = result[swapIndex];');\n      lines.push('    result[swapIndex] = temp;');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arrayUniq')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyUniq = (collection) => {');\n      lines.push('  if (!Array.isArray(collection)) return [];');\n      lines.push('  const seen = new Set();');\n      lines.push('  const result = [];');\n      lines.push('  for (let index = 0; index < collection.length; index += 1) {');\n      lines.push('    const value = collection[index];');\n      lines.push('    if (seen.has(value)) continue;');\n      lines.push('    seen.add(value);');\n      lines.push('    result.push(value);');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arraySample')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubySample = (collection, count) => {');\n      lines.push('  if (!Array.isArray(collection) || collection.length === 0) {');\n      lines.push('    return count === undefined ? undefined : [];');\n      lines.push('  }');\n      lines.push('  if (count === undefined) {');\n      lines.push('    const index = Math.floor(Math.random() * collection.length);');\n      lines.push('    return collection[index];');\n      lines.push('  }');\n      lines.push('  const total = Number(count);');\n      lines.push('  if (!Number.isFinite(total) || total <= 0) return [];');\n      lines.push('  const pool = collection.slice();');\n      lines.push('  const result = [];');\n      lines.push('  const max = Math.min(pool.length, Math.floor(total));');\n      lines.push('  for (let index = 0; index < max; index += 1) {');\n      lines.push('    const pick = Math.floor(Math.random() * pool.length);');\n      lines.push('    const [value] = pool.splice(pick, 1);');\n      lines.push('    result.push(value);');\n      lines.push('  }');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arrayFirst')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyFirst = (collection, count) => {');\n      lines.push('  if (!Array.isArray(collection)) return count === undefined ? undefined : [];');\n      lines.push('  if (count === undefined) return collection[0];');\n      lines.push('  const total = Number(count);');\n      lines.push('  if (!Number.isFinite(total) || total <= 0) return [];');\n      lines.push('  return collection.slice(0, Math.floor(total));');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('arrayLast')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyLast = (collection, count) => {');\n      lines.push('  if (!Array.isArray(collection)) return count === undefined ? undefined : [];');\n      lines.push('  if (count === undefined) return collection.length ? collection[collection.length - 1] : undefined;');\n      lines.push('  const total = Number(count);');\n      lines.push('  if (!Number.isFinite(total) || total <= 0) return [];');\n      lines.push('  const size = Math.floor(total);');\n      lines.push('  if (!collection.length) return [];');\n      lines.push('  const start = Math.max(0, collection.length - size);');\n      lines.push('  return collection.slice(start);');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('symbolProc')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubySymbolProc = (name) => {');\n      lines.push('  switch (name) {');\n      lines.push('    case \"capitalize\":');\n      lines.push('      return (value) => __rubyCapitalize(value);');\n      lines.push('    case \"swapcase\":');\n      lines.push('      return (value) => __rubySwapcase(value);');\n      lines.push('    case \"upcase\":');\n      lines.push('      return (value) => String(value ?? \"\").toUpperCase();');\n      lines.push('    case \"downcase\":');\n      lines.push('      return (value) => String(value ?? \"\").toLowerCase();');\n      lines.push('    case \"reverse\":');\n      lines.push('      return (value) => String(value ?? \"\").split(\"\").reverse().join(\"\");');\n      lines.push('    default:');\n      lines.push('      return (value, ...rest) => {');\n      lines.push('        if (value == null) return value;');\n      lines.push('        const method = value[name];');\n      lines.push('        return typeof method === \"function\" ? method.apply(value, rest) : value;');\n      lines.push('      };');\n      lines.push('  }');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('lazy')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyLazy = (value) => {');\n      lines.push('  if (value && typeof value === \"object\" && value.__isRubyLazy) return value;');\n      lines.push('  if (Array.isArray(value)) {');\n      lines.push('    const base = value.slice();');\n      lines.push('    const wrapper = {');\n      lines.push('      __isRubyLazy: true,');\n      lines.push('      __target: base,');\n      lines.push('      select(block) {');\n      lines.push('        const fn = typeof block === \"function\" ? block : (item) => item;');\n      lines.push('        const result = base.filter((item, index) => fn(item, index));');\n      lines.push('        return __rubyLazy(result);');\n      lines.push('      },');\n      lines.push('      map(block) {');\n      lines.push('        const fn = typeof block === \"function\" ? block : (item) => item;');\n        lines.push('        return __rubyLazy(base.map((item, index) => fn(item, index)));');\n      lines.push('      },');\n      lines.push('      to_a() {');\n      lines.push('        return base.slice();');\n      lines.push('      },');\n      lines.push('      first() {');\n      lines.push('        return base[0];');\n      lines.push('      },');\n      lines.push('      forEach(...args) {');\n      lines.push('        return base.forEach(...args);');\n      lines.push('      }');\n      lines.push('    };');\n      lines.push('    wrapper.filter = wrapper.select;');\n      lines.push('    wrapper[Symbol.iterator] = function() {');\n      lines.push('      return base[Symbol.iterator]();');\n      lines.push('    };');\n      lines.push('    return wrapper;');\n      lines.push('  }');\n      lines.push('  return value;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('range')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyRange = (start, end, exclusive = false) => {');\n      lines.push('  const coerceNumber = (value) => {');\n      lines.push('    if (typeof value === \"number\") return value;');\n      lines.push('    if (typeof value === \"bigint\") return Number(value);');\n      const coerceLogic = [\n        '    const parsed = Number(value);',\n        '    return Number.isNaN(parsed) ? null : parsed;'\n      ];\n      lines.push(...coerceLogic);\n      lines.push('  };');\n      lines.push('  const fromNumber = coerceNumber(start);');\n      lines.push('  const toNumber = coerceNumber(end);');\n      lines.push('  const numeric = fromNumber !== null && toNumber !== null;');\n      lines.push('  const ascending = !numeric ? true : fromNumber <= toNumber;');\n      lines.push('  const buildNumeric = (stepValue) => {');\n      const buildNumericLogic = [\n        '    const step = stepValue === undefined ? (ascending ? 1 : -1) : Number(stepValue);',\n        '    if (!Number.isFinite(step) || step === 0) return [];',\n        '    if (ascending && step < 0) return [];',\n        '    if (!ascending && step > 0) return [];',\n        '    const limit = (value) => {',\n        '      if (ascending) {',\n        '        return exclusive ? value < toNumber : value <= toNumber;',\n        '      }',\n        '      return exclusive ? value > toNumber : value >= toNumber;',\n        '    };',\n        '    const values = [];',\n        '    for (let current = fromNumber; limit(current); current += step) {',\n        '      values.push(current);',\n        '      if (current === toNumber) break;',\n        '    }',\n        '    return values;'\n      ];\n      lines.push(...buildNumericLogic);\n      lines.push('  };');\n      lines.push('  const buildFallback = () => {');\n      lines.push('    const values = [start];');\n      lines.push('    if (!exclusive || start !== end) values.push(end);');\n      lines.push('    return values;');\n      lines.push('  };');\n      lines.push('  const buildValues = (stepValue) => numeric ? buildNumeric(stepValue) : buildFallback();');\n      lines.push('  const range = {');\n      lines.push('    to_a() {');\n      lines.push('      return buildValues();');\n      lines.push('    },');\n      lines.push('    each(block) {');\n      lines.push('      const values = buildValues();');\n      lines.push('      if (typeof block !== \"function\") return values;');\n      lines.push('      for (let index = 0; index < values.length; index += 1) {');\n      lines.push('        block(values[index]);');\n      lines.push('      }');\n      lines.push('      return range;');\n      lines.push('    },');\n      lines.push('    step(stepValue, block) {');\n      lines.push('      let stepAmount = stepValue;');\n      lines.push('      let fn = block;');\n      lines.push('      if (typeof block !== \"function\" && typeof stepValue === \"function\") {');\n      lines.push('        fn = stepValue;');\n        lines.push('        stepAmount = undefined;');\n      lines.push('      }');\n      lines.push('      const values = buildValues(stepAmount);');\n      lines.push('      if (typeof fn !== \"function\") return values;');\n      lines.push('      for (let index = 0; index < values.length; index += 1) {');\n      lines.push('        fn(values[index]);');\n      lines.push('      }');\n      lines.push('      return range;');\n      lines.push('    }');\n      lines.push('  };');\n      lines.push('  range[Symbol.iterator] = function* () {');\n      lines.push('    const values = buildValues();');\n      lines.push('    for (let index = 0; index < values.length; index += 1) {');\n      lines.push('      yield values[index];');\n      lines.push('    }');\n      lines.push('  };');\n      lines.push('  return range;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('fetch')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyFetch = (collection, key, fallback) => {');\n      lines.push('  if (Array.isArray(collection)) {');\n      lines.push('    const index = Number(key);');\n    lines.push('    if (Number.isInteger(index) && index >= 0 && index < collection.length) {');\n      lines.push('      return collection[index];');\n      lines.push('    }');\n      lines.push('  } else if (collection && typeof collection === \"object\") {');\n      lines.push('    const prop = String(key);');\n      lines.push('    if (prop in collection) {');\n      lines.push('      return collection[prop];');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  if (fallback !== undefined) {');\n      lines.push('    return typeof fallback === \"function\" ? fallback() : fallback;');\n      lines.push('  }');\n      lines.push('  throw new Error(\"KeyError\");');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('match')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyMatch = (value, pattern) => {');\n      const logic = [\n        '  let input = value;',\n        '  let regex = pattern;',\n        '  if (value instanceof RegExp || (value && typeof value === \"object\" && typeof value.exec === \"function\")) {',\n        '    regex = value;',\n        '    input = pattern;',\n        '  }',\n        '  const normalizedInput = String(input ?? \"\");',\n        '  const normalizedRegex = regex instanceof RegExp ? regex : new RegExp(String(regex));',\n        '  const result = normalizedInput.match(normalizedRegex);',\n        '  if (!result) return null;',\n        '  const wrapper = {',\n        '    captures: () => result.slice(1)',\n        '  };',\n        '  result.slice(1).forEach((value, index) => { wrapper[index] = value; });',\n        '  if (result.groups && typeof result.groups === \"object\") {',\n        '    for (const [key, value] of Object.entries(result.groups)) {',\n        '      wrapper[key] = value;',\n        '    }',\n        '  }',\n        '  return wrapper;',\n      ];\n      lines.push(...logic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('publicSend')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyPublicSend = (receiver, methodName, ...args) => {');\n      lines.push('  if (receiver == null) return undefined;');\n      lines.push('  const fn = receiver[methodName];');\n      lines.push('  if (typeof fn === \"function\") {');\n      lines.push('    return fn.apply(receiver, args);');\n      lines.push('  }');\n      lines.push('  if (typeof methodName === \"string\") {');\n      lines.push('    const rhs = args[0];');\n      lines.push('    switch (methodName) {');\n      lines.push('      case \">\": return receiver > rhs;');\n      lines.push('      case \">=\": return receiver >= rhs;');\n      lines.push('      case \"<\": return receiver < rhs;');\n      lines.push('      case \"<=\": return receiver <= rhs;');\n      lines.push('      case \"==\": return receiver === rhs;');\n      lines.push('      case \"!=\": return receiver !== rhs;');\n    lines.push('      case \"===\": return receiver === rhs;');\n    lines.push('      case \"!==\": return receiver !== rhs;');\n      lines.push('      default: break;');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  return receiver[methodName];');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('send')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubySend = (receiver, methodName, args = [], block) => {');\n      lines.push('  if (receiver == null) return undefined;');\n      const helperLogic = [\n        '  const fn = receiver[methodName];',\n        '  if (typeof fn === \"function\") {',\n        '    const callArgs = block === undefined ? args : [...args, block];',\n        '    return fn.apply(receiver, callArgs);',\n        '  }',\n        '  if (typeof methodName === \"string\") {',\n        '    if (methodName === \"tap\") {',\n        '      if (typeof block === \"function\") {',\n        '        const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(receiver) : null;',\n        '        try { block.call(receiver, receiver); } finally { if (typeof restore === \"function\") restore(); }',\n        '      }',\n        '      return receiver;',\n        '    }',\n        '    if (methodName === \"then\" || methodName === \"yield_self\") {',\n        '      if (typeof block === \"function\") {',\n        '        const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(receiver) : null;',\n        '        try { return block.call(receiver, receiver); } finally { if (typeof restore === \"function\") restore(); }',\n        '      }',\n        '      return receiver;',\n        '    }',\n        '    if (methodName === \"catch\") {',\n        '      const tag = args[0];',\n        '      if (typeof block !== \"function\") return undefined;',\n        '      const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(receiver) : null;',\n        '      try {',\n        '        return block.call(receiver);',\n        '      } catch (error) {',\n        '        if (error && error.__rubyThrowTag !== undefined) {',\n        '          if (tag === undefined || tag === error.__rubyThrowTag || String(tag) === String(error.__rubyThrowTag)) {',\n        '            return error.__rubyThrowValue;',\n        '          }',\n        '        }',\n        '        throw error;',\n        '      } finally {',\n        '        if (typeof restore === \"function\") restore();',\n        '      }',\n        '    }',\n        '    if (methodName === \"throw\") {',\n        '      const tag = args[0];',\n        '      const value = args.length > 1 ? args[1] : undefined;',\n        '      const error = new Error(\"throw\");',\n        '      error.__rubyThrowTag = tag;',\n        '      error.__rubyThrowValue = value;',\n        '      throw error;',\n        '    }',\n        '  }',\n        '  const missing = receiver.method_missing;',\n        '  if (typeof missing === \"function\") {',\n        '    const missingArgs = block === undefined ? [methodName, ...args] : [methodName, ...args, block];',\n        '    return missing.apply(receiver, missingArgs);',\n        '  }',\n        '  throw new Error(`NoMethodError: undefined method ${methodName}`);',\n      ];\n      lines.push(...helperLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('thread')) {\n      if (lines.length) lines.push('');\n      lines.push('const Thread = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && globalThis.Thread) return globalThis.Thread;');\n      lines.push('  class Thread {');\n      lines.push('    constructor(block) {');\n      lines.push('      this.value = undefined;');\n      lines.push('      Thread.__stack.push(this);');\n      lines.push('      try {');\n      lines.push('        if (typeof block === \"function\") {');\n      lines.push('          const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(this) : null;');\n      lines.push('          try {');\n      lines.push('            this.value = block();');\n      lines.push('          } finally {');\n      lines.push('            if (typeof restore === \"function\") restore();');\n      lines.push('          }');\n      lines.push('        }');\n      lines.push('      } finally {');\n      lines.push('        Thread.__stack.pop();');\n      lines.push('      }');\n      lines.push('    }');\n      lines.push('    static current() {');\n      lines.push('      const stack = Thread.__stack;');\n      lines.push('      return stack[stack.length - 1] || Thread.__root;');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  Thread.__root = {};');\n      lines.push('  Thread.__stack = [Thread.__root];');\n      lines.push('  if (typeof globalThis !== \"undefined\") globalThis.Thread = Thread;');\n      lines.push('  return Thread;');\n      lines.push('})();');\n    }\n\n    if (this.runtimeHelpers.has('fiber')) {\n      if (lines.length) lines.push('');\n      lines.push('const Fiber = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && globalThis.Fiber) return globalThis.Fiber;');\n      lines.push('  class Fiber {');\n      lines.push('    constructor(block) {');\n      lines.push('      this.value = undefined;');\n      lines.push('      this.block = typeof block === \"function\" ? block : null;');\n      lines.push('      if (this.block) {');\n      lines.push('        const restore = typeof this.block.__rubyBind === \"function\" ? this.block.__rubyBind(this) : null;');\n      lines.push('        try {');\n      lines.push('          this.value = this.block();');\n      lines.push('        } finally {');\n      lines.push('          if (typeof restore === \"function\") restore();');\n      lines.push('        }');\n      lines.push('      }');\n      lines.push('    }');\n      lines.push('    static yield() {');\n      lines.push('      return (value) => value;');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  if (typeof globalThis !== \"undefined\") globalThis.Fiber = Fiber;');\n      lines.push('  return Fiber;');\n      lines.push('})();');\n    }\n\n    if (this.runtimeHelpers.has('enumerator')) {\n      if (lines.length) lines.push('');\n      lines.push('const Enumerator = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && globalThis.Enumerator) return globalThis.Enumerator;');\n      lines.push('  class Enumerator {');\n      lines.push('    constructor(block) {');\n      lines.push('      this.__values = [];');\n      lines.push('      this.__builder = typeof block === \"function\" ? block : null;');\n      lines.push('      if (this.__builder) {');\n      lines.push('        const restore = typeof this.__builder.__rubyBind === \"function\" ? this.__builder.__rubyBind(this) : null;');\n      lines.push('        const yielder = {');\n      lines.push('          push: (value) => {');\n      lines.push('            this.__values.push(value);');\n      lines.push('            return value;');\n      lines.push('          }');\n      lines.push('        };');\n      lines.push('        try {');\n      lines.push('          this.__builder(yielder);');\n      lines.push('        } finally {');\n      lines.push('          if (typeof restore === \"function\") restore();');\n      lines.push('        }');\n      lines.push('      }');\n      lines.push('    }');\n      lines.push('    each(block) {');\n      lines.push('      if (typeof block === \"function\") {');\n      lines.push('        for (const value of this.__values) {');\n      lines.push('          const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(this) : null;');\n      lines.push('          try { block.call(this, value); } finally { if (typeof restore === \"function\") restore(); }');\n      lines.push('        }');\n      lines.push('      }');\n      lines.push('      return this;');\n      lines.push('    }');\n      lines.push('    toArray() {');\n      lines.push('      return this.__values.slice();');\n      lines.push('    }');\n      lines.push('    [Symbol.iterator]() {');\n      lines.push('      return this.__values[Symbol.iterator]();');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  if (typeof globalThis !== \"undefined\") globalThis.Enumerator = Enumerator;');\n      lines.push('  return Enumerator;');\n      lines.push('})();');\n    }\n\n    if (this.runtimeHelpers.has('file')) {\n      if (lines.length) lines.push('');\n      lines.push('const File = (() => {');\n      lines.push('  const existing = typeof globalThis !== \"undefined\" ? globalThis.File : undefined;');\n      lines.push('  if (existing && typeof existing.open === \"function\") return existing;');\n      const fileLines = [\n        '  const File = existing && typeof existing === \"object\" ? existing : {};',\n        '  File.open = (path, mode, block) => {',\n        '    const fileObject = {',\n        '      gets: () => \"\"',\n        '    };',\n        '    if (typeof block === \"function\") {',\n        '      const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(fileObject) : null;',\n        '      try {',\n        '        return block.call(fileObject, fileObject);',\n        '      } finally {',\n        '        if (typeof restore === \"function\") restore();',\n        '      }',\n        '    }',\n        '    return fileObject;',\n        '  };',\n        '  if (typeof globalThis !== \"undefined\") globalThis.File = File;',\n        '  return File;'\n      ];\n      lines.push(...fileLines);\n      lines.push('})();');\n    }\n\n    if (this.runtimeHelpers.has('struct')) {\n      if (lines.length) lines.push('');\n      lines.push('const Struct = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && globalThis.Struct) return globalThis.Struct;');\n      lines.push('  class Struct {');\n      lines.push('    constructor(...members) {');\n      lines.push('      const names = members.map(member => {');\n      lines.push('        const stringName = typeof member === \"string\" ? member : String(member);');\n      lines.push('        return stringName.startsWith(\":\") ? stringName.slice(1) : stringName;');\n      lines.push('      });');\n      lines.push('      return class {');\n      lines.push('        constructor(...values) {');\n      lines.push('          names.forEach((name, index) => {');\n      lines.push('            this[name] = values[index];');\n      lines.push('          });');\n      lines.push('        }');\n      lines.push('      };');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  if (typeof globalThis !== \"undefined\") globalThis.Struct = Struct;');\n      lines.push('  return Struct;');\n      lines.push('})();');\n    }\n\n    if (this.runtimeHelpers.has('tracePoint')) {\n      if (lines.length) lines.push('');\n      lines.push('const TracePoint = (() => {');\n      lines.push('  if (typeof globalThis !== \"undefined\" && globalThis.TracePoint) return globalThis.TracePoint;');\n      lines.push('  class TracePoint {');\n      lines.push('    constructor(eventName, block) {');\n      lines.push('      this.eventName = eventName;');\n      lines.push('      this.block = typeof block === \"function\" ? block : null;');\n      lines.push('    }');\n      lines.push('    enable(block) {');\n      lines.push('      const fn = typeof block === \"function\" ? block : this.block;');\n      lines.push('      if (typeof fn === \"function\") {');\n      lines.push('        const restore = typeof fn.__rubyBind === \"function\" ? fn.__rubyBind(this) : null;');\n      lines.push('        try {');\n      lines.push('          return fn.call(this, this);');\n      lines.push('        } finally {');\n      lines.push('          if (typeof restore === \"function\") restore();');\n      lines.push('        }');\n      lines.push('      }');\n      lines.push('      return this;');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('  if (typeof globalThis !== \"undefined\") globalThis.TracePoint = TracePoint;');\n      lines.push('  return TracePoint;');\n      lines.push('})();');\n    }\n\n    if (this.runtimeHelpers.has('instanceEval')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyInstanceEval = (receiver, block) => {');\n      lines.push('  if (typeof block !== \"function\") return undefined;');\n      const evalLogic = [\n        '  const target = receiver !== undefined ? receiver : undefined;',\n        '  const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(target) : null;',\n        '  try {',\n        '    return block.call(target);',\n        '  } finally {',\n        '    if (typeof restore === \"function\") restore();',\n        '  }'\n      ];\n      lines.push(...evalLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('instanceExec')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyInstanceExec = (receiver, args, block) => {');\n      lines.push('  if (typeof block !== \"function\") return undefined;');\n      const execLogic = [\n        '  const target = receiver !== undefined ? receiver : undefined;',\n        '  const argList = Array.isArray(args) ? args : [];',\n        '  const restore = typeof block.__rubyBind === \"function\" ? block.__rubyBind(target) : null;',\n        '  try {',\n        '    return block.apply(target, argList);',\n        '  } finally {',\n        '    if (typeof restore === \"function\") restore();',\n        '  }'\n      ];\n      lines.push(...execLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('multiAssign')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyMultiAssign = (value, count) => {');\n      lines.push('  if (value == null) {');\n      lines.push('    return Array.from({ length: count }, () => undefined);');\n      lines.push('  }');\n      lines.push('  if (Array.isArray(value)) {');\n      lines.push('    const result = value.slice(0, count);');\n      lines.push('    while (result.length < count) result.push(undefined);');\n      lines.push('    return result;');\n      lines.push('  }');\n      lines.push('  const result = [value];');\n      lines.push('  while (result.length < count) result.push(undefined);');\n      lines.push('  return result;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('chomp')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyChomp = (value) => {');\n      lines.push('  const str = String(value ?? \"\");');\n      lines.push('  if (str.endsWith(\"\\\\r\\\\n\")) return str.slice(0, -2);');\n      lines.push('  if (str.endsWith(\"\\\\n\")) return str.slice(0, -1);');\n      lines.push('  if (str.endsWith(\"\\\\r\")) return str.slice(0, -1);');\n      lines.push('  return str;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('toInteger')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyToInteger = (value) => {');\n      lines.push('  const str = String(value ?? \"\").trimStart();');\n      lines.push('  const match = str.match(/^[+-]?\\\\d+/);');\n      lines.push('  if (!match) return 0;');\n      lines.push('  const parsed = parseInt(match[0], 10);');\n      lines.push('  return Number.isNaN(parsed) ? 0 : parsed;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('toFloat')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyToFloat = (value) => {');\n      lines.push('  const num = parseFloat(String(value ?? \"\"));');\n      lines.push('  return Number.isNaN(num) ? 0 : num;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('strftime')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyStrftime = (format) => {');\n      lines.push('  const date = new Date();');\n      lines.push('  const replacements = {');\n      lines.push('    \"%Y\": String(date.getFullYear()),');\n      lines.push('    \"%m\": String(date.getMonth() + 1).padStart(2, \"0\"),');\n      lines.push('    \"%d\": String(date.getDate()).padStart(2, \"0\")');\n      lines.push('  };');\n      lines.push('  return String(format ?? \"\").replace(/%[Ymd]/g, (match) => replacements[match] ?? match);');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('rescueMatch')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyRescueMatch = (error, matchers) => {');\n      lines.push('  if (!matchers || matchers.length === 0) return true;');\n      lines.push('  for (const matcher of matchers) {');\n      lines.push('    if (matcher == null) continue;');\n      lines.push('    if (typeof matcher === \"function\") {');\n      lines.push('      if (error instanceof matcher) return true;');\n      lines.push('      continue;');\n      lines.push('    }');\n      lines.push('    if (typeof matcher === \"string\") {');\n      lines.push('      if (error && error.name === matcher) return true;');\n      lines.push('      continue;');\n      lines.push('    }');\n      lines.push('    if (typeof matcher === \"object\" && typeof matcher.test === \"function\") {');\n      lines.push('      if (matcher.test(error)) return true;');\n      lines.push('      continue;');\n      lines.push('    }');\n      lines.push('    if (matcher === error) return true;');\n      lines.push('    if (String(matcher) === (error && error.name)) return true;');\n      lines.push('  }');\n      lines.push('  return false;');\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('includeMixin')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyInclude = (klass, mixin) => {');\n      lines.push('  if (!klass || !mixin) return klass;');\n      const includeLogic = [\n        '  const target = klass && klass.prototype ? klass.prototype : klass;',\n        '  const descriptors = Object.getOwnPropertyDescriptors(mixin);',\n        '  for (const key of Reflect.ownKeys(descriptors)) {',\n        '    if (key === \"constructor\") continue;',\n        '    Object.defineProperty(target, key, descriptors[key]);',\n        '  }',\n        '  return klass;',\n      ];\n      lines.push(...includeLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('extendMixin')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyExtend = (klass, mixin) => {');\n      lines.push('  if (!klass || !mixin) return klass;');\n      const extendLogic = [\n        '  const descriptors = Object.getOwnPropertyDescriptors(mixin);',\n        '  for (const key of Reflect.ownKeys(descriptors)) {',\n        '    if (key === \"constructor\") continue;',\n        '    Object.defineProperty(klass, key, descriptors[key]);',\n        '  }',\n        '  return klass;',\n      ];\n      lines.push(...extendLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('prependMixin')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyPrepend = (klass, mixin) => {');\n      lines.push('  if (!klass || !mixin) return klass;');\n      const prependLogic = [\n        '  const target = klass && klass.prototype ? klass.prototype : klass;',\n        '  const descriptors = Object.getOwnPropertyDescriptors(mixin);',\n        '  for (const key of Reflect.ownKeys(descriptors)) {',\n        '    if (key === \"constructor\") continue;',\n        '    Object.defineProperty(target, key, descriptors[key]);',\n        '  }',\n        '  return klass;',\n      ];\n      lines.push(...prependLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('defineSingleton')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyDefineSingleton = (target, name, fn) => {');\n      lines.push('  if (target == null) return undefined;');\n      lines.push('  const key = name == null ? undefined : (typeof name === \"symbol\" ? name : String(name));');\n      const defineLogic = [\n        '  if (key === undefined) return undefined;',\n        '  const assignKey = key;',\n        '  const callable = typeof fn === \"function\" ? fn : (() => fn);',\n        '  target[assignKey] = callable;',\n        '  return callable;',\n      ];\n      lines.push(...defineLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('ensureError')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyEnsureError = (name) => {');\n      const ensureLogic = [\n        '  const errorName = typeof name === \"string\" ? name : String(name ?? \"Error\");',\n        '  if (typeof globalThis !== \"undefined\") {',\n        '    const existing = globalThis[errorName];',\n        '    if (typeof existing === \"function\") return existing;',\n        '    const ctor = class extends Error {',\n        '      constructor(message) {',\n        '        super(message);',\n        '        this.name = errorName;',\n        '      }',\n        '    };',\n        '    Object.defineProperty(ctor, \"name\", { value: errorName });',\n        '    globalThis[errorName] = ctor;',\n        '    return ctor;',\n        '  }',\n        '  return Error;',\n      ];\n      lines.push(...ensureLogic);\n      lines.push('};');\n    }\n\n    if (this.runtimeHelpers.has('raise')) {\n      if (lines.length) lines.push('');\n      lines.push('const __rubyRaise = (...args) => {');\n      const raiseLogic = [\n        '  if (!args.length) { throw new Error(\"RuntimeError\"); }',\n        '  const first = args[0];',\n        '  if (first instanceof Error) { throw first; }',\n        '  if (typeof first === \"function\") {',\n        '    const message = args[1] !== undefined ? args[1] : undefined;',\n        '    throw new first(message);',\n        '  }',\n        '  if (typeof first === \"string\") {',\n        '    throw new Error(first);',\n        '  }',\n        '  if (first && typeof first === \"object\" && first.message !== undefined) {',\n        '    throw first;',\n        '  }',\n        '  throw new Error(String(first));',\n      ];\n      lines.push(...raiseLogic);\n      lines.push('};');\n    }\n\n    return lines;\n  }\n\n  emitStatement(node, context = {}) {\n    switch (node.type) {\n      case 'ExpressionStatement':\n        return this.emitExpressionStatement(node, context);\n      case 'MethodDefinition':\n        return this.emitMethodDefinition(node, context);\n      case 'ClassDeclaration':\n        return this.emitClassDeclaration(node, context);\n      case 'ModuleDeclaration':\n        return this.emitModuleDeclaration(node, context);\n      case 'IfStatement':\n        return this.emitIfStatement(node, context);\n      case 'WhileStatement':\n        return this.emitWhileStatement(node, context);\n      case 'LoopStatement':\n        return this.emitLoopStatement(node, context);\n      case 'ReturnStatement':\n        return this.indent() + this.emitReturnStatement(node, context);\n      case 'BlockStatement':\n        return this.indent() + this.emitBlockStatement(node, context);\n      case 'CaseStatement':\n        return this.emitCaseStatement(node, context);\n      case 'BreakStatement':\n        return this.indent() + 'break;';\n      case 'UsingStatement':\n        return this.emitUsingStatement(node, context);\n      case 'SingletonClassDeclaration':\n        return this.emitSingletonClassDeclaration(node, context);\n      default:\n        throw new Error(`Unsupported statement type: ${node.type}`);\n    }\n  }\n\n  emitExpressionStatement(node, context = {}) {\n    const indent = this.indent();\n    const expressionNode = node.expression;\n\n    if (this.isAttrMacroCall(expressionNode)) {\n      return this.emitAttrMacro(expressionNode, context);\n    }\n\n    if (this.isRequireCall(expressionNode)) {\n      return this.emitRequireCall(expressionNode, context);\n    }\n\n    if (this.isExtendCall(expressionNode)) {\n      return this.emitExtendCall(expressionNode, context);\n    }\n\n    if (this.isDefDelegatorsCall(expressionNode, context)) {\n      return this.emitDefDelegators(expressionNode, context);\n    }\n\n    if (this.isRefineCall(expressionNode)) {\n      return this.emitRefineCall(expressionNode, context);\n    }\n\n    const normalized = this.normalizeExpressionForStatement(expressionNode, context);\n    const expressionCode = this.emitExpression(normalized, { ...context, statement: true });\n    if (expressionCode === '') return null;\n\n    if (context.inFunction && context.isTail && context.allowImplicitReturn !== false) {\n      return `${indent}return ${expressionCode};`;\n    }\n\n    return `${indent}${expressionCode};`;\n  }\n\n  normalizeExpressionForStatement(expr, context = {}) {\n    if (!expr) return expr;\n    if (expr.type === 'CallExpression') return expr;\n    if (expr.type === 'AssignmentExpression') return expr;\n    if (expr.type === 'Identifier') {\n      if (this.isIdentifierDeclared(expr.name, context)) {\n        return expr;\n      }\n      return { type: 'CallExpression', callee: expr, arguments: [] };\n    }\n    if (expr.type === 'MemberExpression' || expr.type === 'OptionalMemberExpression') {\n      return { type: 'CallExpression', callee: expr, arguments: [] };\n    }\n    return expr;\n  }\n\n  isAttrMacroCall(expr) {\n    if (!expr || expr.type !== 'CallExpression') return false;\n    if (expr.callee.type !== 'Identifier') return false;\n    return ['attr_accessor', 'attr_reader', 'attr_writer'].includes(expr.callee.name);\n  }\n\n  emitAttrMacro(expr, context) {\n    const indent = this.indent();\n    const attributeNames = expr.arguments\n      .map(arg => this.extractSymbolName(arg) ?? (arg.type === 'StringLiteral' ? arg.value : null))\n      .filter(Boolean);\n\n    if (!attributeNames.length) {\n      const args = expr.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return `${indent}// ${expr.callee.name}(${args})`;\n    }\n\n    const target = context.currentClassName\n      ? `${context.currentClassName}.prototype`\n      : 'this';\n\n    const lines = [];\n    for (const name of attributeNames) {\n      const ivar = this.instanceVariableKey(name);\n      if (expr.callee.name !== 'attr_writer') {\n        lines.push(`${target}[${this.quote(name)}] = function() { return this.${ivar}; };`);\n      }\n      if (expr.callee.name !== 'attr_reader') {\n        lines.push(`${target}[${this.quote(`${name}=`)}] = function(value) { this.${ivar} = value; return value; };`);\n      }\n    }\n    return lines.join('\\n');\n  }\n\n  isRequireCall(expr) {\n    return expr && expr.type === 'CallExpression' && expr.callee.type === 'Identifier' && expr.callee.name === 'require';\n  }\n\n  emitRequireCall(expr, context) {\n    const indent = this.indent();\n    if (!expr.arguments.length) {\n      return `${indent}// require`;\n    }\n    const first = expr.arguments[0];\n    if (first.type === 'StringLiteral') {\n      if (first.value === 'forwardable') {\n        if (this.injectedRequires.has('forwardable')) {\n          return `${indent}// require \"forwardable\"`;\n        }\n        this.injectedRequires.add('forwardable');\n        return `${indent}const Forwardable = {};`;\n      }\n      return `${indent}// require \"${first.value}\"`;\n    }\n    const rendered = this.emitExpression(first, context);\n    return `${indent}// require ${rendered}`;\n  }\n\n  isExtendCall(expr) {\n    return expr && expr.type === 'CallExpression' && expr.callee.type === 'Identifier' && expr.callee.name === 'extend';\n  }\n\n  emitExtendCall(expr, context) {\n    const indent = this.indent();\n    const args = expr.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n    return `${indent}// extend ${args}`;\n  }\n\n  isDefDelegatorsCall(expr, context) {\n    return expr && expr.type === 'CallExpression' && expr.callee.type === 'Identifier' && expr.callee.name === 'def_delegators';\n  }\n\n  emitDefDelegators(expr, context = {}) {\n    const indent = this.indent();\n    const methods = expr.arguments.slice(1)\n      .map(arg => this.resolveDelegatorMethodName(arg))\n      .filter(Boolean);\n\n    if (!methods.length) {\n      const args = expr.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return `${indent}// def_delegators(${args})`;\n    }\n\n    if (!context.inClass) {\n      const args = expr.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return `${indent}// def_delegators(${args})`;\n    }\n\n    const className = context.currentClassName;\n    const receiver = className ? `${className}.prototype` : 'this';\n    const target = this.resolveDelegatorTarget(expr.arguments[0], context);\n    const lines = [];\n\n    const innerIndent = ' '.repeat(this.indentSize);\n    for (const methodName of methods) {\n      lines.push(`${receiver}[${this.quote(methodName)}] = function(...args) {`);\n      lines.push(`${innerIndent}const __target = ${target};`);\n      lines.push(`${innerIndent}const __fn = __target != null ? __target[${this.quote(methodName)}] : undefined;`);\n      lines.push(`${innerIndent}return typeof __fn === \"function\" ? __fn.apply(__target, args) : undefined;`);\n      lines.push('};');\n    }\n\n    return lines.join('\\n');\n  }\n\n  resolveDelegatorTarget(node, context) {\n    if (!node) return 'this';\n    if (node.type === 'SymbolLiteral') {\n      const name = node.name;\n      if (name.startsWith('@@')) {\n        const prop = name.slice(2);\n        const owner = context.currentClassName ? `${context.currentClassName}` : 'this.constructor';\n        return `${owner}.${prop}`;\n      }\n      if (name.startsWith('@')) {\n        return this.instanceVariableReference(name.slice(1));\n      }\n      return `this[${this.quote(name)}]`;\n    }\n    return this.emitExpression(node, context);\n  }\n\n  resolveDelegatorMethodName(node) {\n    if (!node) return null;\n    if (node.type === 'SymbolLiteral') return node.name;\n    if (node.type === 'Identifier') return node.name;\n    if (node.type === 'StringLiteral') return node.value;\n    return null;\n  }\n\n  prepareMethodParameters(params, scope, options = {}) {\n    const structures = [];\n    let hasKeywords = false;\n    let hasForwarding = false;\n\n    for (const param of params) {\n      switch (param.type) {\n        case 'Identifier': {\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'positional', name: safeName, original: param.name });\n          break;\n        }\n        case 'OptionalParameter': {\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'optional', name: safeName, original: param.name, default: param.default });\n          break;\n        }\n        case 'RestParameter': {\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'rest', name: safeName });\n          break;\n        }\n        case 'BlockParameter': {\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'block', name: safeName });\n          break;\n        }\n        case 'KeywordParameter': {\n          hasKeywords = true;\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'keywordRequired', name: safeName, key: param.name });\n          break;\n        }\n        case 'KeywordOptionalParameter': {\n          hasKeywords = true;\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'keywordOptional', name: safeName, key: param.name, default: param.default });\n          break;\n        }\n        case 'KeywordRestParameter': {\n          hasKeywords = true;\n          const safeName = this.getRenamedName(scope, param.name);\n          structures.push({ kind: 'keywordRest', name: safeName });\n          break;\n        }\n        case 'ForwardingParameter': {\n          hasForwarding = true;\n          structures.push({ kind: 'forwarding' });\n          break;\n        }\n        default:\n          throw new Error(`Unsupported parameter type: ${param.type}`);\n      }\n    }\n\n    const useGeneric = hasKeywords || hasForwarding;\n\n    const result = {\n      useGeneric,\n      paramSignature: [],\n      optionalParams: [],\n      blockParamName: null,\n      blockFromRest: null,\n      genericInfo: null\n    };\n\n    if (useGeneric) {\n      const rawArgsName = this.generateUniqueId('__args');\n      const positional = [];\n      const optional = [];\n      let restName = null;\n      const keywordRequired = [];\n      const keywordOptional = [];\n      let keywordRest = null;\n      let blockName = null;\n\n      for (const info of structures) {\n        switch (info.kind) {\n          case 'positional':\n            positional.push({ name: info.name });\n            break;\n          case 'optional':\n            optional.push({ name: info.name, default: info.default });\n            break;\n          case 'rest':\n            restName = info.name;\n            break;\n          case 'block':\n            blockName = info.name;\n            break;\n          case 'keywordRequired':\n            keywordRequired.push({ name: info.name, key: info.key });\n            break;\n          case 'keywordOptional':\n            keywordOptional.push({ name: info.name, key: info.key, default: info.default });\n            break;\n          case 'keywordRest':\n            keywordRest = info.name;\n            break;\n          case 'forwarding':\n            // no additional data needed here\n            break;\n          default:\n            break;\n        }\n      }\n\n      if (!blockName && options.usesYield) {\n        blockName = '__block';\n      }\n\n      result.paramSignature = [`...${rawArgsName}`];\n      result.blockParamName = blockName;\n      result.genericInfo = {\n        rawArgsName,\n        positional,\n        optional,\n        rest: restName,\n        keywordRequired,\n        keywordOptional,\n        keywordRest,\n        hasExplicitKeywords: hasKeywords,\n        blockParamName: blockName,\n        usesYield: options.usesYield,\n        forwarding: hasForwarding\n      };\n    } else {\n      const paramNames = [];\n      let restName = null;\n      let blockName = null;\n      let blockFromRest = null;\n      const optionalParams = [];\n\n      for (const info of structures) {\n        switch (info.kind) {\n          case 'positional':\n            paramNames.push(info.name);\n            break;\n          case 'optional':\n            paramNames.push(info.name);\n            optionalParams.push({ name: info.name, default: info.default });\n            break;\n          case 'rest':\n            paramNames.push(`...${info.name}`);\n            restName = info.name;\n            break;\n          case 'block':\n            blockName = info.name;\n            if (restName) {\n              blockFromRest = { rest: restName, block: info.name };\n            } else {\n              paramNames.push(info.name);\n            }\n            break;\n          default:\n            // should not reach here without generic handling\n            break;\n        }\n      }\n\n      if (options.usesYield && !blockName) {\n        blockName = '__block';\n        if (restName) {\n          blockFromRest = { rest: restName, block: blockName };\n        } else {\n          paramNames.push(blockName);\n        }\n      }\n\n      result.paramSignature = paramNames;\n      result.optionalParams = optionalParams;\n      result.blockParamName = blockName;\n      result.blockFromRest = blockFromRest;\n    }\n\n    return result;\n  }\n\n  isRefineCall(expr) {\n    return expr && expr.type === 'CallExpression' && expr.callee.type === 'Identifier' && expr.callee.name === 'refine';\n  }\n\n  emitRefineCall(expr, context) {\n    const indent = this.indent();\n    let targetExpr = 'Object';\n    let blockNode = expr.block;\n\n    if (!blockNode && expr.arguments[0] && expr.arguments[0].type === 'CallExpression' && expr.arguments[0].block) {\n      targetExpr = this.emitExpression(expr.arguments[0].callee, context);\n      blockNode = expr.arguments[0].block;\n    } else if (expr.arguments[0]) {\n      targetExpr = this.emitExpression(expr.arguments[0], context);\n    }\n\n    if (!blockNode) {\n      const args = expr.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return `${indent}// refine(${args})`;\n    }\n\n    const lines = [];\n    const bodyStatements = blockNode.body.body;\n\n    for (const statement of bodyStatements) {\n      if (statement.type === 'MethodDefinition') {\n        lines.push(this.emitRefinedMethod(targetExpr, statement, context));\n      } else {\n        const stmt = this.emitStatement(statement, context);\n        if (stmt) lines.push(stmt);\n      }\n    }\n\n    if (!lines.length) {\n      return `${indent}// refine ${targetExpr}`;\n    }\n\n    return lines.join('\\n');\n  }\n\n  emitRefinedMethod(targetExpr, methodNode, context) {\n    const indent = this.indent();\n    const scope = this.scopeInfo.get(methodNode);\n    const parameterAnalysis = this.prepareMethodParameters(methodNode.params, scope, { usesYield: !!methodNode.usesYield });\n    const paramsCode = parameterAnalysis.paramSignature.join(', ');\n    const fnBody = this.emitFunctionBody(\n      methodNode.body,\n      {\n        ...context,\n        scopeNode: methodNode,\n        scopeStack: [methodNode, ...(context.scopeStack || [])],\n        inFunction: true,\n        allowImplicitReturn: true,\n        methodType: 'instance',\n        blockParamName: parameterAnalysis.blockParamName,\n        optionalParams: parameterAnalysis.optionalParams,\n        blockFromRest: parameterAnalysis.blockFromRest,\n        methodBlockInfo: parameterAnalysis.blockFromRest,\n        currentMethodName: methodNode.id.name,\n        ...(parameterAnalysis.genericInfo ? { genericArgsInfo: parameterAnalysis.genericInfo } : {})\n      },\n      scope\n    );\n\n    return `${indent}${targetExpr}.prototype[${this.quote(methodNode.id.name)}] = function(${paramsCode}) ${fnBody};`;\n  }\n\n  emitExpression(node, context = {}) {\n    switch (node.type) {\n      case 'Identifier': {\n        const name = node.name;\n        const resolved = this.resolveIdentifierName(name, context);\n        if (resolved !== name) {\n          return resolved;\n        }\n        const declared = this.isIdentifierDeclared(name, context);\n        if (!declared) {\n          const allowGlobal = context && context.allowGlobalIdentifier;\n          if (name === '__FILE__') {\n            this.requireRuntime('fileConstant');\n            return '__FILE__';\n          }\n          if (name === 'binding') {\n            this.requireRuntime('bindingHelper');\n            return '__rubyBinding()';\n          }\n          if (name === 'JS') {\n            this.requireRuntime('jsBridge');\n            return 'JS';\n          }\n          const runtimeConstants = {\n            Thread: 'thread',\n            Fiber: 'fiber',\n            Enumerator: 'enumerator',\n            File: 'file',\n            Struct: 'struct',\n            TracePoint: 'tracePoint'\n          };\n          if (Object.prototype.hasOwnProperty.call(runtimeConstants, name)) {\n            this.requireRuntime(runtimeConstants[name]);\n            return name;\n          }\n          if (/^[A-Z]/.test(name) && this.isRubyExceptionConstant(name)) {\n            this.requireRuntime('ensureError');\n            return `__rubyEnsureError(${this.quote(name)})`;\n          }\n          if (/^[A-Z]/.test(name)) {\n            return name;\n          }\n          if (allowGlobal) {\n            return name;\n          }\n          this.requireRuntime('send');\n          const receiver = this.resolveImplicitCallReceiver(context);\n          return `__rubySend(${receiver}, ${this.quote(name)}, [], undefined)`;\n        }\n        if (!context.disableMethodLookup && this.isMethodName(name, context)) {\n          this.requireRuntime('send');\n          const receiver = this.resolveImplicitCallReceiver(context);\n          return `__rubySend(${receiver}, ${this.quote(name)}, [], undefined)`;\n        }\n        return resolved;\n      }\n      case 'InstanceVariable':\n        return this.instanceVariableReference(node.name);\n      case 'ClassVariable':\n        return `this.constructor.${node.name}`;\n      case 'SelfExpression':\n        return 'this';\n      case 'NumericLiteral':\n        return String(node.value);\n      case 'StringLiteral':\n        return this.emitStringLiteral(node, context);\n      case 'RegExpLiteral':\n        return this.emitRegExpLiteral(node);\n      case 'BooleanLiteral':\n        return node.value ? 'true' : 'false';\n      case 'NullLiteral':\n        return 'null';\n      case 'RangeExpression':\n        return this.emitRangeExpression(node, context);\n      case 'SymbolLiteral':\n        return this.quote(node.name);\n      case 'ArrayExpression':\n        return `[${node.elements.map(el => this.emitExpression(el, context)).join(', ')}]`;\n      case 'HashExpression':\n        return this.emitObjectLiteral(node, context);\n      case 'UnaryExpression':\n        return `${node.operator}${this.emitExpression(node.argument, context)}`;\n      case 'BinaryExpression':\n        return this.emitBinaryExpression(node, context);\n      case 'LogicalExpression':\n        return `${this.emitExpression(node.left, context)} ${node.operator} ${this.emitExpression(node.right, context)}`;\n      case 'AssignmentExpression':\n        return this.emitAssignmentExpression(node, context);\n      case 'MultiAssignmentExpression':\n        return this.emitMultiAssignmentExpression(node, context);\n      case 'CallExpression':\n        return this.emitCallExpression(node, context);\n      case 'MemberExpression':\n        return this.emitMemberExpression(node, context);\n      case 'OptionalMemberExpression':\n        return this.emitOptionalMemberExpression(node, context);\n      case 'BlockStatement':\n        return this.emitBlockStatement(node, context);\n      case 'ConditionalExpression':\n        return `${this.emitExpression(node.test, context)} ? ${this.emitExpression(node.consequent, context)} : ${this.emitExpression(node.alternate, context)}`;\n      case 'LambdaExpression':\n        return this.emitLambdaExpression(node, context);\n      case 'YieldExpression':\n        return this.emitYieldExpression(node, context);\n      case 'SuperCall':\n        return this.emitSuperCall(node, context);\n      case 'BeginRescueExpression':\n        return this.emitBeginRescueExpression(node, context);\n      default:\n        throw new Error(`Unsupported expression type: ${node.type}`);\n    }\n  }\n\n  emitAssignmentExpression(node, context) {\n    if (node.operator === '=') {\n      if (node.left.type === 'MemberExpression') {\n        if (node.left.computed) {\n          const objectContext = {\n            ...context,\n            disableMethodLookup: true,\n            allowGlobalIdentifier: true\n          };\n          if (\n            node.left.object &&\n            node.left.object.type === 'Identifier' &&\n            context.methodType === 'static' &&\n            this.isMethodName(node.left.object.name, context)\n          ) {\n            objectContext.disableMethodLookup = false;\n            objectContext.allowGlobalIdentifier = false;\n          }\n          const objectExpr = this.emitExpression(node.left.object, objectContext);\n          const keyExpr = this.emitExpression(node.left.property, context);\n          const valueExpr = this.emitExpression(node.right, context);\n          const objectTemp = this.generateUniqueId('__stringAssignTarget');\n          const keyTemp = this.generateUniqueId('__stringAssignKey');\n          const valueTemp = this.generateUniqueId('__stringAssignValue');\n          const resultTemp = this.generateUniqueId('__stringAssignResult');\n          const assignableTarget = this.resolveStringAssignableTarget(node.left.object, context);\n          const lines = [];\n          lines.push('(() => {');\n          lines.push(`  const ${objectTemp} = ${objectExpr};`);\n          lines.push(`  const ${keyTemp} = ${keyExpr};`);\n          lines.push(`  const ${valueTemp} = ${valueExpr};`);\n          if (assignableTarget) {\n            this.requireRuntime('stringAssign');\n            lines.push(`  if (typeof ${objectTemp} === 'string' || ${objectTemp} instanceof String) {`);\n            lines.push(`    const ${resultTemp} = __rubyStringAssign(${objectTemp}, ${keyTemp}, ${valueTemp});`);\n            lines.push(`    ${assignableTarget} = ${resultTemp};`);\n            lines.push(`    return ${valueTemp};`);\n            lines.push('  }');\n          }\n          lines.push(`  ${objectTemp}[${keyTemp}] = ${valueTemp};`);\n          lines.push(`  return ${valueTemp};`);\n          lines.push('})()');\n          return lines.join('\\n');\n        } else if (node.left.property.type === 'Identifier') {\n          const objectCode = this.emitExpression(node.left.object, context);\n          const rightExpr = this.emitExpression(node.right, context);\n          const methodName = `${node.left.property.name}=`;\n          return `${objectCode}[${this.quote(methodName)}](${rightExpr})`;\n        }\n      }\n      const leftExpr = this.emitAssignmentTarget(node.left, context);\n      const rightExpr = this.emitExpression(node.right, context);\n      return `${leftExpr} = ${rightExpr}`;\n    }\n    const left = this.emitAssignmentTarget(node.left, context);\n    const right = this.emitExpression(node.right, context);\n    return `${left} ${node.operator} ${right}`;\n  }\n\n  emitMultiAssignmentExpression(node, context) {\n    const targets = node.targets.map(target => this.emitAssignmentTarget(target, context));\n    const right = this.emitExpression(node.right, context);\n    if (targets.length <= 1) {\n      const target = targets[0] ?? 'undefined';\n      return `${target} = ${right}`;\n    }\n    this.requireRuntime('multiAssign');\n    const tempVar = this.generateUniqueId('__multi');\n    const destructure = `[${targets.join(', ')}] = __rubyMultiAssign(${tempVar}, ${targets.length});`;\n    return `(() => { const ${tempVar} = ${right}; ${destructure} return ${tempVar}; })()`;\n  }\n\n  emitAssignmentTarget(target, context) {\n    if (!target) return 'undefined';\n    switch (target.type) {\n      case 'Identifier':\n        return this.resolveIdentifierName(target.name, context);\n      case 'InstanceVariable':\n        return this.instanceVariableReference(target.name);\n      case 'MemberExpression':\n      case 'OptionalMemberExpression':\n        return this.emitExpression(target, context);\n      default:\n        return this.emitExpression(target, context);\n    }\n  }\n\n  resolveStringAssignableTarget(target, context) {\n    if (!target) return null;\n    switch (target.type) {\n      case 'Identifier': {\n        if (!this.isIdentifierDeclared(target.name, context)) {\n          return null;\n        }\n        const resolved = this.resolveIdentifierName(target.name, context);\n        return resolved ?? null;\n      }\n      case 'InstanceVariable':\n        return this.instanceVariableReference(target.name);\n      case 'ClassVariable':\n        return `this.constructor.${target.name}`;\n      default:\n        return null;\n    }\n  }\n\n  emitCallExpression(node, context) {\n    const calleeName = this.extractCalleeName(node.callee);\n    const receiverCode = this.extractCalleeObjectCode(node.callee, context);\n\n    const processedArgs = [];\n    let blockPassExpression = null;\n    for (const arg of node.arguments) {\n      if (arg && arg.type === 'BlockPassExpression') {\n        blockPassExpression = this.emitBlockPassExpression(arg, context);\n        continue;\n      }\n      if (arg && arg.type === 'ForwardingArguments') {\n        processedArgs.push({ node: arg, code: null });\n        continue;\n      }\n      processedArgs.push({ node: arg, code: this.emitArgumentExpression(arg, context) });\n    }\n\n    const inlineBlockNode = node.block || null;\n    const inlineBlockCode = inlineBlockNode ? this.emitBlockFunction(inlineBlockNode, context, { forceImplicitIdentifiers: true }) : null;\n    let blockCode = inlineBlockCode || blockPassExpression;\n\n    if (calleeName === 'proc') {\n      if (blockCode) {\n        return blockCode;\n      }\n      if (processedArgs.length) {\n        const codes = processedArgs.map(entry => entry.code);\n        return `${calleeName}(${codes.join(', ')})`;\n      }\n      return `${calleeName}()`;\n    }\n\n    if (\n      node.callee.type === 'MemberExpression' &&\n      !node.callee.computed &&\n      node.callee.object.type === 'Identifier' &&\n      node.callee.object.name === 'Proc' &&\n      node.callee.property.type === 'Identifier' &&\n      node.callee.property.name === 'new'\n    ) {\n      if (node.block) {\n        return this.emitBlockFunction(node.block, context, { forceImplicitIdentifiers: true });\n      }\n    }\n\n    if (calleeName === 'block_given?') {\n      return this.emitBlockGiven(context);\n    }\n\n    const isMemberIdentifier = node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property.type === 'Identifier';\n    const visibilityKeywords = new Set(['private', 'public', 'protected', 'module_function']);\n    if (calleeName && !isMemberIdentifier && visibilityKeywords.has(calleeName)) {\n      return '';\n    }\n\n    if (calleeName === 'include' && !isMemberIdentifier) {\n      return this.emitIncludeCall(node, context);\n    }\n\n    if (calleeName === 'extend' && !isMemberIdentifier) {\n      return this.emitExtendCall(node, context);\n    }\n\n    if (calleeName === 'prepend' && !isMemberIdentifier) {\n      return this.emitPrependCall(node, context);\n    }\n\n    if (calleeName === 'define_method') {\n      return this.emitDefineMethod(node, context);\n    }\n\n    if (calleeName === 'instance_variable_get') {\n      return this.emitInstanceVariableGet(node, context, receiverCode);\n    }\n\n    if (calleeName === 'instance_variable_set') {\n      return this.emitInstanceVariableSet(node, context, receiverCode);\n    }\n\n    if (calleeName === 'eval') {\n      this.requireRuntime('putsGlobal');\n    }\n\n    if (calleeName === 'puts') {\n      const args = node.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return `console.log(${args})`;\n    }\n\n    if (calleeName === 'print') {\n      this.requireRuntime('print');\n      const args = node.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return args.length ? `__rubyPrint(${args})` : '__rubyPrint()';\n    }\n\n    if (calleeName === 'p') {\n      const args = node.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return args.length ? `console.log(${args})` : 'console.log()';\n    }\n\n    if (calleeName === 'gets') {\n      this.requireRuntime('gets');\n      const args = node.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return args.length ? `__rubyGets(${args})` : '__rubyGets()';\n    }\n\n    const callArgs = this.buildCallArguments(processedArgs, blockCode);\n    const { finalArgCodes, argsArray, argsWithBlock, blockArg } = callArgs;\n\n    if (node.callee.type === 'Identifier' && calleeName === 'raise') {\n      this.requireRuntime('raise');\n      const raiseArgs = argsWithBlock.join(', ');\n      return raiseArgs.length ? `__rubyRaise(${raiseArgs})` : '__rubyRaise()';\n    }\n\n    let memberProperty = null;\n    let memberObjectCode = null;\n    if (\n      node.callee.type === 'OptionalMemberExpression' &&\n      !node.callee.computed &&\n      node.callee.property.type === 'Identifier'\n    ) {\n      memberProperty = node.callee.property.name;\n      memberObjectCode = this.emitExpression(node.callee.object, {\n        ...context,\n        disableMethodLookup: true,\n        allowGlobalIdentifier: true\n      });\n    } else if (\n      node.callee.type === 'MemberExpression' &&\n      !node.callee.computed &&\n      node.callee.property.type === 'Identifier'\n    ) {\n      memberProperty = node.callee.property.name;\n      memberObjectCode = this.emitExpression(node.callee.object, {\n        ...context,\n        disableMethodLookup: true,\n        allowGlobalIdentifier: true\n      });\n\n      if (\n        node.callee.object.type === 'Identifier' &&\n        node.callee.object.name === 'gets'\n      ) {\n        memberObjectCode = this.emitGetsCall();\n      }\n    }\n\n    if (memberProperty && memberObjectCode) {\n      const bangInfo = this.getStringBangInfo(memberProperty);\n      if (\n        bangInfo &&\n        node.arguments.length === 0 &&\n        node.callee.object &&\n        node.callee.object.type === 'Identifier'\n      ) {\n        this.requireRuntime(bangInfo.runtime);\n        if (bangInfo.dependencies) {\n          for (const dep of bangInfo.dependencies) {\n            this.requireRuntime(dep);\n          }\n        }\n        return `(() => { ${memberObjectCode} = ${bangInfo.helper}(${memberObjectCode}); return ${memberObjectCode}; })()`;\n      }\n\n      if (memberProperty === 'times' && node.arguments.length === 0) {\n        this.requireRuntime('times');\n        if (blockCode) {\n          return `__rubyTimes(${memberObjectCode}, ${blockCode})`;\n        }\n        return `__rubyTimes(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'upto' && processedArgs.length >= 1) {\n        this.requireRuntime('upto');\n        const limitArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        if (blockCode) {\n          return `__rubyUpto(${memberObjectCode}, ${limitArg}, ${blockCode})`;\n        }\n        return `__rubyUpto(${memberObjectCode}, ${limitArg})`;\n      }\n\n      if (memberProperty === 'downto' && processedArgs.length >= 1) {\n        this.requireRuntime('downto');\n        const limitArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        if (blockCode) {\n          return `__rubyDownto(${memberObjectCode}, ${limitArg}, ${blockCode})`;\n        }\n        return `__rubyDownto(${memberObjectCode}, ${limitArg})`;\n      }\n\n      if (memberProperty === 'public_send') {\n        const methodArg = node.arguments[0];\n        const methodNameLiteral = this.extractSymbolName(methodArg);\n        if (methodNameLiteral && node.arguments.length >= 2) {\n          const right = this.emitExpression(node.arguments[1], context);\n          const left = memberObjectCode;\n          const operatorMap = {\n            '==': '===',\n            '!=': '!=='\n          };\n          const jsOperator = operatorMap[methodNameLiteral] ?? methodNameLiteral;\n          if (['>', '>=', '<', '<=', '===', '!=='].includes(jsOperator)) {\n            return `${left} ${jsOperator} ${right}`;\n          }\n        }\n        this.requireRuntime('publicSend');\n        const argCodes = node.arguments.map(arg => this.emitExpression(arg, context));\n        const argsTail = argCodes.length ? `, ${argCodes.join(', ')}` : '';\n        return `__rubyPublicSend(${memberObjectCode}${argsTail})`;\n      }\n\n      if (memberProperty === 'strftime' && this.isTimeNowExpression(node.callee.object)) {\n        this.requireRuntime('strftime');\n        const format = node.arguments[0] ? this.emitExpression(node.arguments[0], context) : 'undefined';\n        return `__rubyStrftime(${format})`;\n      }\n\n      if (memberProperty === 'strip' && node.arguments.length === 0) {\n        this.requireRuntime('strip');\n        return `__rubyStrip(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'upcase' && node.arguments.length === 0) {\n        this.requireRuntime('upcase');\n        return `__rubyUpcase(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'downcase' && node.arguments.length === 0) {\n        this.requireRuntime('downcase');\n        return `__rubyDowncase(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'split' && node.arguments.length === 0) {\n        this.requireRuntime('split');\n        return `__rubySplit(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'chomp' && node.arguments.length === 0) {\n        this.requireRuntime('chomp');\n        return `__rubyChomp(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'reverse' && node.arguments.length === 0) {\n        this.requireRuntime('reverseString');\n        return `__rubyReverse(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'capitalize' && node.arguments.length === 0) {\n        this.requireRuntime('capitalize');\n        return `__rubyCapitalize(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'swapcase' && node.arguments.length === 0) {\n        this.requireRuntime('swapcase');\n        return `__rubySwapcase(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'ljust') {\n        this.requireRuntime('ljust');\n        const widthArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        const padArg = processedArgs[1] && processedArgs[1].code ? processedArgs[1].code : 'undefined';\n        return `__rubyLjust(${memberObjectCode}, ${widthArg}, ${padArg})`;\n      }\n\n      if (memberProperty === 'rjust') {\n        this.requireRuntime('rjust');\n        const widthArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        const padArg = processedArgs[1] && processedArgs[1].code ? processedArgs[1].code : 'undefined';\n        return `__rubyRjust(${memberObjectCode}, ${widthArg}, ${padArg})`;\n      }\n\n      if (memberProperty === 'max' && node.arguments.length === 0) {\n        return `Math.max(...${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'chars' && node.arguments.length === 0) {\n        this.requireRuntime('chars');\n        return `__rubyChars(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'gsub' && processedArgs.length >= 1) {\n        this.requireRuntime('gsub');\n        const patternArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        const replacementArg = processedArgs[1] && processedArgs[1].code ? processedArgs[1].code : 'undefined';\n        if (blockCode) {\n          return `__rubyGsub(${memberObjectCode}, ${patternArg}, undefined, ${blockCode})`;\n        }\n        return `__rubyGsub(${memberObjectCode}, ${patternArg}, ${replacementArg})`;\n      }\n\n      if (memberProperty === 'include?' && node.arguments.length === 1) {\n        this.requireRuntime('collectionInclude');\n        const searchValue = this.emitExpression(node.arguments[0], context);\n        return `__rubyCollectionInclude(${memberObjectCode}, ${searchValue})`;\n      }\n\n      if (memberProperty === 'to_i' && node.arguments.length === 0) {\n        this.requireRuntime('toInteger');\n        return `__rubyToInteger(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'to_f' && node.arguments.length === 0) {\n        this.requireRuntime('toFloat');\n        return `__rubyToFloat(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'to_sym' && node.arguments.length === 0) {\n        return `String(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'to_s' && node.arguments.length === 0) {\n        return `String(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'size' && node.arguments.length === 0) {\n        return `${memberObjectCode}.length`;\n      }\n\n      if (memberProperty === 'is_a?' && node.arguments.length === 1) {\n        const argNode = node.arguments[0];\n        if (argNode.type === 'Identifier' && argNode.name === 'Proc') {\n          const objectRef = memberObjectCode ?? this.emitExpression(node.callee.object, context);\n          return `typeof ${objectRef} === 'function'`;\n        }\n      }\n\n      if (memberProperty === 'select' && blockCode) {\n        return `${memberObjectCode}.filter(${blockCode})`;\n      }\n\n      if (memberProperty === 'reject') {\n        this.requireRuntime('arrayReject');\n        if (blockCode) {\n          return `__rubyReject(${memberObjectCode}, ${blockCode})`;\n        }\n        return `__rubyReject(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'class' && node.arguments.length === 0) {\n        this.requireRuntime('className');\n        return `__rubyClassName(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'freeze' && node.arguments.length === 0) {\n        return `Object.freeze(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'lazy' && node.arguments.length === 0) {\n        this.requireRuntime('lazy');\n        return `__rubyLazy(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'fetch') {\n        this.requireRuntime('fetch');\n        const indexArg = node.arguments[0] ? this.emitExpression(node.arguments[0], context) : 'undefined';\n        if (node.arguments.length > 1) {\n          const defaultArg = this.emitExpression(node.arguments[1], context);\n          return `__rubyFetch(${memberObjectCode}, ${indexArg}, ${defaultArg})`;\n        }\n        return `__rubyFetch(${memberObjectCode}, ${indexArg})`;\n      }\n\n      if (memberProperty === 'first') {\n        this.requireRuntime('arrayFirst');\n        const countArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        return `__rubyFirst(${memberObjectCode}${processedArgs.length ? `, ${countArg}` : ''})`;\n      }\n\n      if (memberProperty === 'last') {\n        this.requireRuntime('arrayLast');\n        const countArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        return `__rubyLast(${memberObjectCode}${processedArgs.length ? `, ${countArg}` : ''})`;\n      }\n\n      if (memberProperty === 'push') {\n        this.requireRuntime('arrayPush');\n        const pushArgs = processedArgs.map(arg => arg.code).filter(Boolean);\n        const argsTail = pushArgs.length ? `, ${pushArgs.join(', ')}` : '';\n        return `__rubyArrayPush(${memberObjectCode}${argsTail})`;\n      }\n\n      if (memberProperty === 'shuffle' && node.arguments.length === 0 && !blockCode) {\n        this.requireRuntime('arrayShuffle');\n        return `__rubyShuffle(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'uniq' && node.arguments.length === 0 && !blockCode) {\n        this.requireRuntime('arrayUniq');\n        return `__rubyUniq(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'sample') {\n        this.requireRuntime('arraySample');\n        const sampleArg = processedArgs[0] && processedArgs[0].code ? processedArgs[0].code : 'undefined';\n        return processedArgs.length ? `__rubySample(${memberObjectCode}, ${sampleArg})` : `__rubySample(${memberObjectCode})`;\n      }\n\n      if (memberProperty === 'match') {\n        this.requireRuntime('match');\n        const pattern = node.arguments[0] ? this.emitExpression(node.arguments[0], context) : 'undefined';\n        return `__rubyMatch(${memberObjectCode}, ${pattern})`;\n      }\n\n      if (memberProperty === 'instance_eval' && blockCode && !processedArgs.length) {\n        this.requireRuntime('instanceEval');\n        const evalBlock = inlineBlockNode\n          ? this.emitBlockFunction(inlineBlockNode, context, { forceImplicitIdentifiers: true })\n          : blockCode;\n        return `__rubyInstanceEval(${memberObjectCode}, ${evalBlock})`;\n      }\n\n      if (memberProperty === 'instance_exec' && blockCode) {\n        this.requireRuntime('instanceExec');\n        const execArgs = finalArgCodes.length ? `[${finalArgCodes.join(', ')}]` : '[]';\n        return `__rubyInstanceExec(${memberObjectCode}, ${execArgs}, ${blockCode})`;\n      }\n\n      if (memberProperty === 'define_singleton_method') {\n        return this.emitDefineSingletonMethodCall(node, context, {\n          objectCode: memberObjectCode,\n          inlineBlockNode,\n          blockCode,\n          processedArgs\n        });\n      }\n    }\n\n    let isConstructorCall = false;\n    let calleeCode;\n\n    if (\n      node.callee.type === 'MemberExpression' &&\n      !node.callee.computed &&\n      node.callee.property.type === 'Identifier' &&\n      node.callee.property.name === 'new'\n    ) {\n      calleeCode = this.emitExpression(node.callee.object, context);\n      isConstructorCall = true;\n    } else if (node.callee.type === 'Identifier' && context.classLevel && context.currentClassName) {\n      calleeCode = `${context.currentClassName}.${node.callee.name}`;\n    } else if (node.callee.type === 'Identifier' && context.methodType === 'instance') {\n      const scope = context.scopeNode ? this.scopeInfo.get(context.scopeNode) : null;\n      const isDeclared = scope ? scope.declared.has(node.callee.name) : false;\n      calleeCode = isDeclared ? node.callee.name : `this.${node.callee.name}`;\n    } else if (node.callee.type === 'Identifier') {\n      if (\n        context.methodType === 'static' &&\n        !this.isIdentifierDeclared(node.callee.name, context) &&\n        this.isMethodName(node.callee.name, context)\n      ) {\n        calleeCode = `this.${node.callee.name}`;\n      } else {\n        calleeCode = node.callee.name;\n      }\n    } else {\n      calleeCode = this.emitExpression(node.callee, { ...context, disableMethodLookup: true });\n    }\n\n    const hasForwardingArg = processedArgs.some(entry => entry.node && entry.node.type === 'ForwardingArguments');\n\n    if (hasForwardingArg) {\n      const explicitArgs = processedArgs.filter(entry => !entry.node || entry.node.type !== 'ForwardingArguments');\n      if (explicitArgs.length) {\n        throw new Error('Forwarding arguments cannot be combined with explicit arguments in this transpiler');\n      }\n      const forwardingInfo = context.forwardingInfo;\n      if (!forwardingInfo) {\n        throw new Error('Forwarding arguments used outside of a forwarding method');\n      }\n      const positionalName = forwardingInfo.positionalName;\n      const keywordExpr = forwardingInfo.keywordName || 'undefined';\n      const blockExpr = forwardingInfo.blockName || 'undefined';\n      const argsExpr = `(${keywordExpr} === undefined ? ${positionalName}.slice() : ${positionalName}.concat(${keywordExpr}))`;\n\n      if (!memberProperty && node.callee.type === 'Identifier') {\n        if (calleeName === 'eval') {\n          const evalArgsExpr = blockExpr !== 'undefined' ? `${argsExpr}.concat(${blockExpr})` : argsExpr;\n          return `eval.apply(undefined, ${evalArgsExpr})`;\n        }\n        this.requireRuntime('send');\n        const implicitReceiver = this.resolveImplicitCallReceiver(context);\n        return `__rubySend(${implicitReceiver}, ${this.quote(calleeName)}, ${argsExpr}, ${blockExpr})`;\n      }\n\n      if (memberProperty) {\n        this.requireRuntime('send');\n        return `__rubySend(${memberObjectCode}, ${this.quote(memberProperty)}, ${argsExpr}, ${blockExpr})`;\n      }\n\n      // Fallback for direct callable expressions\n      const appliedArgs = blockExpr !== 'undefined' ? `${argsExpr}.concat(${blockExpr})` : argsExpr;\n      return `${calleeCode}.apply(this, ${appliedArgs})`;\n    }\n\n    if (!memberProperty && node.callee.type === 'Identifier') {\n      if (calleeName === 'instance_eval' && blockCode && !finalArgCodes.length) {\n        this.requireRuntime('instanceEval');\n        const receiverExpr = this.resolveImplicitCallReceiver(context);\n        const evalBlock = inlineBlockNode\n          ? this.emitBlockFunction(inlineBlockNode, context, { forceImplicitIdentifiers: true })\n          : blockCode;\n        return `__rubyInstanceEval(${receiverExpr}, ${evalBlock})`;\n      }\n\n      if (calleeName === 'instance_exec' && blockCode) {\n        this.requireRuntime('instanceExec');\n        const execArgs = finalArgCodes.length ? `[${finalArgCodes.join(', ')}]` : '[]';\n        const receiverExpr = this.resolveImplicitCallReceiver(context);\n        return `__rubyInstanceExec(${receiverExpr}, ${execArgs}, ${blockCode})`;\n      }\n\n      if (calleeName === 'eval') {\n        const callArgs = argsWithBlock.join(', ');\n        return callArgs.length ? `eval(${callArgs})` : 'eval()';\n      }\n      const handledNames = ['proc', 'instance_eval', 'instance_exec', 'block_given?', 'define_method', 'instance_variable_get', 'instance_variable_set', 'puts', 'print', 'gets'];\n      const isStaticMethod = context.methodType === 'static' && this.isMethodName(node.callee.name, context);\n      const needsImplicitSend = !this.isValidMethodName(node.callee.name) || (!this.isIdentifierDeclared(node.callee.name, context) && !handledNames.includes(node.callee.name) && !isStaticMethod);\n      if (needsImplicitSend) {\n        if (context.forceImplicitIdentifiers || !this.isValidMethodName(node.callee.name)) {\n          this.requireRuntime('send');\n          const implicitReceiver = this.resolveImplicitCallReceiver(context);\n          return `__rubySend(${implicitReceiver}, ${this.quote(node.callee.name)}, ${argsArray}, ${blockArg})`;\n        }\n      }\n    }\n\n    if (memberProperty === 'call' && node.callee.type !== 'OptionalMemberExpression') {\n      const args = finalArgCodes.join(', ');\n      return `${memberObjectCode}(${args})`;\n    }\n\n    if (\n      blockCode &&\n      node.callee.type === 'MemberExpression' &&\n      !node.callee.computed &&\n      node.callee.property.type === 'Identifier' &&\n      (node.callee.property.name === 'each' || node.callee.property.name === 'each_with_index')\n    ) {\n      const objectCode = this.emitExpression(node.callee.object, context);\n      let iteratorBlock = blockCode;\n      if (inlineBlockNode) {\n        const functionBlock = this.emitBlockFunction(inlineBlockNode, context, { forceImplicitIdentifiers: true, asFunction: true });\n        iteratorBlock = this.convertFunctionToArrow(functionBlock);\n      }\n      return `${objectCode}.forEach(${iteratorBlock})`;\n    }\n\n    if (node.callee.type === 'OptionalMemberExpression') {\n      const objectCode = this.emitExpression(node.callee.object, context);\n      const args = argsWithBlock.join(', ');\n      const callSuffix = args.length ? `(${args})` : '()';\n      if (node.callee.computed) {\n        const propertyCode = this.emitExpression(node.callee.property, context);\n        return `${objectCode}?.[${propertyCode}]${callSuffix}`;\n      }\n      return `${objectCode}?.${node.callee.property.name}${callSuffix}`;\n    }\n\n    if (\n      this.isFastMode() &&\n      !isConstructorCall &&\n      node.callee.type === 'MemberExpression' &&\n      !node.callee.computed &&\n      node.callee.property.type === 'Identifier' &&\n      !blockCode &&\n      blockArg === 'undefined' &&\n      !hasForwardingArg &&\n      !inlineBlockNode\n    ) {\n      const objectCode = this.emitExpression(node.callee.object, {\n        ...context,\n        disableMethodLookup: true,\n        allowGlobalIdentifier: true\n      });\n      const args = finalArgCodes.join(', ');\n      const callSuffix = args.length ? `(${args})` : '()';\n      return `${objectCode}.${node.callee.property.name}${callSuffix}`;\n    }\n\n    if (!isConstructorCall && node.callee.type === 'MemberExpression' && !node.callee.computed && node.callee.property.type === 'Identifier') {\n      this.requireRuntime('send');\n      const objectCode = this.emitExpression(node.callee.object, {\n        ...context,\n        disableMethodLookup: true,\n        allowGlobalIdentifier: true\n      });\n      return `__rubySend(${objectCode}, ${this.quote(node.callee.property.name)}, ${argsArray}, ${blockArg})`;\n    }\n\n    if (isConstructorCall) {\n      const ctorArgs = argsWithBlock.join(', ');\n      return `new ${calleeCode}(${ctorArgs})`;\n    }\n\n    return `${calleeCode}(${argsWithBlock.join(', ')})`;\n  }\n  extractCalleeName(callee) {\n    if (!callee) return null;\n    if (callee.type === 'Identifier') return callee.name;\n    if (callee.type === 'MemberExpression' && !callee.computed && callee.property.type === 'Identifier') {\n      return callee.property.name;\n    }\n    return null;\n  }\n\n  extractCalleeObjectCode(callee, context) {\n    if (callee && callee.type === 'MemberExpression') {\n      const objectContext = {\n        ...context,\n        disableMethodLookup: true,\n        allowGlobalIdentifier: true\n      };\n      if (\n        callee.object &&\n        callee.object.type === 'Identifier' &&\n        context.methodType === 'static' &&\n        this.isMethodName(callee.object.name, context)\n      ) {\n        objectContext.disableMethodLookup = false;\n        objectContext.allowGlobalIdentifier = false;\n      }\n      return this.emitExpression(callee.object, objectContext);\n    }\n    return null;\n  }\n\n  extractSymbolName(node) {\n    if (!node) return null;\n    if (node.type === 'SymbolLiteral') return node.name;\n    if (node.type === 'StringLiteral') return node.value;\n    if (node.type === 'Identifier' && !node.name.startsWith('__')) return node.name;\n    return null;\n  }\n\n  emitArgumentExpression(arg, context) {\n    if (!arg) return '';\n    if (arg.type === 'ToProcExpression') {\n      return this.emitToProcExpression(arg, context);\n    }\n    if (arg.type === 'BlockPassExpression') {\n      return this.emitBlockPassExpression(arg, context);\n    }\n    return this.emitExpression(arg, context);\n  }\n\n  buildCallArguments(processedArgs, blockCode) {\n    const positionalArgs = [];\n    const keywordArgs = [];\n\n    for (const entry of processedArgs) {\n      if (entry.node && entry.node.keyword) {\n        keywordArgs.push(entry);\n      } else {\n        positionalArgs.push(entry);\n      }\n    }\n\n    let keywordObjectCode = null;\n    if (keywordArgs.length === 1) {\n      keywordObjectCode = keywordArgs[0].code;\n    } else if (keywordArgs.length > 1) {\n      keywordObjectCode = `Object.assign({}, ${keywordArgs.map(arg => arg.code).join(', ')})`;\n    }\n\n    const positionalCodes = positionalArgs.map(entry => entry.code);\n    const finalArgCodes = keywordObjectCode ? [...positionalCodes, keywordObjectCode] : [...positionalCodes];\n    const argsArray = finalArgCodes.length ? `[${finalArgCodes.join(', ')}]` : '[]';\n    const blockArg = blockCode ? blockCode : 'undefined';\n    const argsWithBlock = blockCode ? [...finalArgCodes, blockCode] : [...finalArgCodes];\n\n    return {\n      positionalArgs,\n      keywordArgs,\n      keywordObjectCode,\n      positionalCodes,\n      finalArgCodes,\n      argsArray,\n      blockArg,\n      argsWithBlock\n    };\n  }\n\n  emitToProcExpression(node, context) {\n    if (node.argument.type === 'SymbolLiteral') {\n      const name = node.argument.name;\n      this.requireRuntime('symbolProc');\n      if (name === 'capitalize') {\n        this.requireRuntime('capitalize');\n      }\n      if (name === 'swapcase') {\n        this.requireRuntime('swapcase');\n      }\n      return `__rubySymbolProc(${this.quote(name)})`;\n    }\n    return this.emitExpression(node.argument, context);\n  }\n\n  emitGetsCall() {\n    this.requireRuntime('gets');\n    return '__rubyGets()';\n  }\n\n  emitBlockPassExpression(node, context) {\n    if (node.expression.type === 'ToProcExpression') {\n      return this.emitToProcExpression(node.expression, context);\n    }\n    return this.emitExpression(node.expression, context);\n  }\n\n  emitLambdaExpression(node, context = {}) {\n    const scope = this.scopeInfo.get(node);\n    let paramNames = node.params.map(param => this.getRenamedName(scope, param.name));\n    if (!paramNames.length) {\n      const inferred = this.inferImplicitParams(node.body);\n      if (scope) {\n        inferred.forEach(name => scope.declared.add(name));\n      }\n      paramNames = inferred;\n    }\n    const paramsCode = paramNames.length ? `(${paramNames.join(', ')})` : '()';\n    const body = this.emitFunctionBody(\n      node.body,\n      {\n        ...context,\n        scopeNode: node,\n        scopeStack: [node, ...(context.scopeStack || [])],\n        inFunction: true,\n        allowImplicitReturn: true,\n        blockParamName: null\n      },\n      scope\n    );\n    return `${paramsCode} => ${body}`;\n  }\n\n  emitYieldExpression(node, context = {}) {\n    const args = node.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n    const target = context.blockParamName ?? '__block';\n    const call = args.length ? `${target}(${args})` : `${target}()`;\n    return `${target} ? ${call} : undefined`;\n  }\n\n  emitBlockGiven(context = {}) {\n    const target = context.blockParamName ?? '__block';\n    return `typeof ${target} === 'function'`;\n  }\n\n  emitSuperCall(node, context = {}) {\n    const methodName = context.currentMethodName;\n    const isStatic = context.methodType === 'static';\n    const hasArgs = node.arguments && node.arguments.length > 0;\n    const argExpressions = hasArgs\n      ? node.arguments.map(arg => this.emitExpression(arg, context))\n      : [];\n    const argList = argExpressions.join(', ');\n\n    if (methodName) {\n      const accessor = this.isValidMethodName(methodName)\n        ? `super.${methodName}`\n        : `super[${this.quote(methodName)}]`;\n      const receiver = isStatic ? 'this' : 'this';\n      const guardLines = [];\n      guardLines.push(`(() => {`);\n      guardLines.push(`  const __superMethod = ${accessor};`);\n      guardLines.push(`  if (typeof __superMethod !== 'function') {`);\n      if (methodName === 'method_missing') {\n        const receiverExpr = isStatic ? 'this' : 'this';\n        const missingExpr = argExpressions.length ? argExpressions[0] : 'arguments[0]';\n        guardLines.push(`    throw new Error(\"NoMethodError: undefined method \" + String(${missingExpr}) + \" for \" + String(${receiverExpr}));`);\n      } else {\n        guardLines.push(`    throw new Error(${this.quote(`NoMethodError: super has no method ${methodName}`)});`);\n      }\n      guardLines.push('  }');\n      if (hasArgs) {\n        guardLines.push(`  return __superMethod.call(${receiver}${argList.length ? ', ' + argList : ''});`);\n      } else {\n        guardLines.push(`  return __superMethod.apply(${receiver}, arguments);`);\n      }\n      guardLines.push('})()');\n      return guardLines.join(' ');\n    }\n\n    if (hasArgs) {\n      return `super(${argList})`;\n    }\n    return 'super(...arguments)';\n  }\n\n  resolveDefineMethodTarget(context, callee) {\n    if (callee && callee.type === 'MemberExpression') {\n      return `${this.emitExpression(callee.object, context)}.prototype`;\n    }\n    if (context.methodType === 'static') {\n      return 'this.prototype';\n    }\n    if (context.classLevel && context.currentClassName) {\n      return `${context.currentClassName}.prototype`;\n    }\n    return 'this';\n  }\n\n  resolveImplicitReceiver(context) {\n    if (context.methodType === 'static') return 'this';\n    if (context.classLevel && context.currentClassName) {\n      return `${context.currentClassName}.prototype`;\n    }\n    return 'this';\n  }\n\n  emitDefineMethod(node, context) {\n    if (!node.block) {\n      const callee = this.emitExpression(node.callee, context);\n      const args = node.arguments.map(arg => this.emitExpression(arg, context)).join(', ');\n      return `${callee}(${args})`;\n    }\n\n    const nameArg = node.arguments[0] ? this.emitExpression(node.arguments[0], context) : 'undefined';\n    const target = this.resolveDefineMethodTarget(context, node.callee);\n    const blockContext = { ...context, methodType: 'instance' };\n    delete blockContext.classLevel;\n    const fn = this.emitBlockFunction(node.block, blockContext, { asFunction: true });\n    return `${target}[${nameArg}] = ${fn}`;\n  }\n\n  emitInstanceVariableGet(node, context, receiverCode) {\n    const target = receiverCode ?? this.resolveImplicitReceiver(context);\n    const arg = node.arguments[0] ? this.emitExpression(node.arguments[0], context) : 'undefined';\n    this.requireRuntime('ivarName');\n    return `${target}[__rubyIvarName(${arg})]`;\n  }\n\n  emitInstanceVariableSet(node, context, receiverCode) {\n    const target = receiverCode ?? this.resolveImplicitReceiver(context);\n    const nameArg = node.arguments[0] ? this.emitExpression(node.arguments[0], context) : 'undefined';\n    const valueArg = node.arguments[1] ? this.emitExpression(node.arguments[1], context) : 'undefined';\n    this.requireRuntime('ivarName');\n    return `${target}[__rubyIvarName(${nameArg})] = ${valueArg}`;\n  }\n\n  emitBeginRescueExpression(node, context = {}) {\n    const resultVar = this.generateUniqueId('__result');\n    const handledVar = this.generateUniqueId('__handled');\n    const errorVar = this.generateUniqueId('__error');\n\n    const lines = ['(() => {'];\n    this.indentLevel += 1;\n    lines.push(`${this.indent()}let ${resultVar};`);\n    lines.push(`${this.indent()}let ${handledVar} = false;`);\n\n    const bodyScope = this.scopeInfo.get(node.body);\n    const tryContext = {\n      ...context,\n      scopeNode: node.body,\n      scopeStack: [node.body, ...(context.scopeStack || [])],\n      inFunction: true,\n      allowImplicitReturn: true\n    };\n    const bodyCode = this.emitFunctionBody(node.body, tryContext, bodyScope);\n\n    lines.push(`${this.indent()}try {`);\n    this.indentLevel += 1;\n    lines.push(`${this.indent()}${resultVar} = (() => ${bodyCode}).call(this);`);\n\n    if (node.elseBody) {\n      const elseScope = this.scopeInfo.get(node.elseBody);\n      const elseContext = {\n        ...context,\n        scopeNode: node.elseBody,\n        scopeStack: [node.elseBody, ...(context.scopeStack || [])],\n        inFunction: true,\n        allowImplicitReturn: true\n      };\n      const elseCode = this.emitFunctionBody(node.elseBody, elseContext, elseScope);\n      lines.push(`${this.indent()}${resultVar} = (() => ${elseCode}).call(this);`);\n    }\n\n    this.indentLevel -= 1;\n    lines.push(`${this.indent()}} catch (${errorVar}) {`);\n    this.indentLevel += 1;\n\n    if (node.rescues && node.rescues.length) {\n      for (const clause of node.rescues) {\n        const condition = this.buildRescueCondition(clause, errorVar, context);\n        const clauseScope = this.scopeInfo.get(clause.body);\n        const clauseContext = {\n          ...context,\n          scopeNode: clause.body,\n          scopeStack: [clause.body, ...(context.scopeStack || [])],\n          inFunction: true,\n          allowImplicitReturn: true\n        };\n        const clauseBody = this.emitFunctionBody(clause.body, clauseContext, clauseScope);\n        lines.push(`${this.indent()}if (!${handledVar} && ${condition}) {`);\n        this.indentLevel += 1;\n        if (clause.binding) {\n          const bindingName = this.getRenamedName(clauseScope, clause.binding.name);\n          lines.push(`${this.indent()}const ${bindingName} = ${errorVar};`);\n        }\n        lines.push(`${this.indent()}${resultVar} = (() => ${clauseBody}).call(this);`);\n        lines.push(`${this.indent()}${handledVar} = true;`);\n        this.indentLevel -= 1;\n        lines.push(`${this.indent()}}`);\n      }\n    }\n\n    lines.push(`${this.indent()}if (!${handledVar}) throw ${errorVar};`);\n    this.indentLevel -= 1;\n\n    if (node.ensureBody) {\n      const ensureBlock = this.emitBlockStatement(node.ensureBody, {\n        ...context,\n        scopeStack: [node.ensureBody, ...(context.scopeStack || [])]\n      });\n      lines.push(`${this.indent()}} finally ${ensureBlock}`);\n    } else {\n      lines.push(`${this.indent()}}`);\n    }\n\n    lines.push(`${this.indent()}return ${resultVar};`);\n    this.indentLevel -= 1;\n    lines.push(`${this.indent()}})();`);\n    return lines.join('\\n');\n  }\n\n  buildRescueCondition(clause, errorVar, context) {\n    if (!clause.exceptions || !clause.exceptions.length) {\n      return 'true';\n    }\n    this.requireRuntime('rescueMatch');\n    const expressions = clause.exceptions.map(exception => this.emitRescueMatcher(exception, context));\n    const matcherList = expressions.join(', ');\n    return `__rubyRescueMatch(${errorVar}, [${matcherList}])`;\n  }\n\n  emitRescueMatcher(node, context) {\n    if (!node) return 'undefined';\n    if (node.type === 'Identifier' && /^[A-Z]/.test(node.name)) {\n      return this.quote(node.name);\n    }\n    return this.emitExpression(node, context);\n  }\n\n  instanceVariableReference(name) {\n    return `this.${this.instanceVariableKey(name)}`;\n  }\n\n  instanceVariableKey(name) {\n    return `__${name}`;\n  }\n\n  isTimeNowExpression(node) {\n    if (!node) return false;\n    if (node.type === 'CallExpression') {\n      return this.isTimeNowExpression(node.callee);\n    }\n    if (node.type === 'MemberExpression' && !node.computed) {\n      const isNow = node.property.type === 'Identifier' && node.property.name === 'now';\n      if (isNow) {\n        return node.object && node.object.type === 'Identifier' && node.object.name === 'Time';\n      }\n      return false;\n    }\n    return false;\n  }\n\n  emitMemberExpression(node, context) {\n    const objectContext = {\n      ...context,\n      disableMethodLookup: true,\n      allowGlobalIdentifier: true\n    };\n    if (\n      node.object &&\n      node.object.type === 'Identifier' &&\n      context.methodType === 'static' &&\n      this.isMethodName(node.object.name, context)\n    ) {\n      objectContext.disableMethodLookup = false;\n      objectContext.allowGlobalIdentifier = false;\n    }\n    const objectCode = this.emitExpression(node.object, objectContext);\n    if (node.computed) {\n      if (this.isFastMode()) {\n        const staticName = this.getStaticPropertyName(node.property);\n        if (staticName && this.isSafeJsIdentifier(staticName)) {\n          return `${objectCode}.${staticName}`;\n        }\n      }\n      const propertyCode = this.emitExpression(node.property, context);\n      return `${objectCode}[${propertyCode}]`;\n    }\n    return `${objectCode}.${node.property.name}`;\n  }\n\n  emitOptionalMemberExpression(node, context) {\n    const objectContext = {\n      ...context,\n      disableMethodLookup: true,\n      allowGlobalIdentifier: true\n    };\n    if (\n      node.object &&\n      node.object.type === 'Identifier' &&\n      context.methodType === 'static' &&\n      this.isMethodName(node.object.name, context)\n    ) {\n      objectContext.disableMethodLookup = false;\n      objectContext.allowGlobalIdentifier = false;\n    }\n    let objectCode = this.emitExpression(node.object, objectContext);\n    if (['LogicalExpression', 'BinaryExpression', 'ConditionalExpression'].includes(node.object.type)) {\n      objectCode = `(${objectCode})`;\n    }\n    if (node.computed) {\n      if (this.isFastMode()) {\n        const staticName = this.getStaticPropertyName(node.property);\n        if (staticName && this.isSafeJsIdentifier(staticName)) {\n          return `${objectCode}?.${staticName}`;\n        }\n      }\n      const propertyCode = this.emitExpression(node.property, context);\n      return `${objectCode}?.[${propertyCode}]`;\n    }\n    return `${objectCode}?.${node.property.name}`;\n  }\n\n  emitObjectLiteral(node, context) {\n    const props = node.properties.map(prop => {\n      const key = this.formatObjectKey(prop.key);\n      const value = this.emitExpression(prop.value, context);\n      return `${key}: ${value}`;\n    });\n    return `{ ${props.join(', ')} }`;\n  }\n\n  emitBinaryExpression(node, context) {\n    if (node.operator === '<<') {\n      this.requireRuntime('arrayPush');\n      const left = this.emitExpression(node.left, context);\n      const right = this.emitExpression(node.right, context);\n      return `__rubyArrayPush(${left}, ${right})`;\n    }\n    const leftExpr = this.emitExpression(node.left, context);\n    const rightExpr = this.emitExpression(node.right, context);\n    const wrappedLeft = this.wrapBinaryOperand(node.left, leftExpr);\n    const wrappedRight = this.wrapBinaryOperand(node.right, rightExpr);\n\n    const fastNumericOps = ['+', '-', '*', '/', '%'];\n    if (this.isFastMode() && fastNumericOps.includes(node.operator)) {\n      if (this.isManifestlyNumeric(node.left) && this.isManifestlyNumeric(node.right)) {\n        return `${wrappedLeft} ${node.operator} ${wrappedRight}`;\n      }\n    }\n\n    if (node.operator === '-') {\n      this.requireRuntime('minus');\n      return `__rubyMinus(${leftExpr}, ${rightExpr})`;\n    }\n\n    return `${wrappedLeft} ${this.mapBinaryOperator(node.operator)} ${wrappedRight}`;\n  }\n\n  emitStringLiteral(node, context) {\n    if (!node.value.includes('#{')) {\n      return this.quote(node.value);\n    }\n    const parts = this.splitInterpolatedString(node.value);\n    const rendered = parts.map(part => {\n      if (part.type === 'text') {\n        return this.escapeTemplateText(part.value);\n      }\n      const expressionNode = this.parseEmbeddedExpression(part.value);\n      return '${' + this.emitExpression(expressionNode, context) + '}';\n    });\n    return '`' + rendered.join('') + '`';\n  }\n\n  emitRegExpLiteral(node) {\n    let source = node.pattern\n      .replace(/\\\\A/g, '^')\n      .replace(/\\\\z/g, '$');\n    const pattern = JSON.stringify(source).slice(1, -1);\n    let filteredFlags = (node.flags || '').replace(/[^gimuy]/g, '');\n    if (!filteredFlags.includes('u') && /\\(\\?<[^>]+>/.test(source)) {\n      filteredFlags += 'u';\n    }\n    return `new RegExp(\"${pattern}\", \"${filteredFlags}\")`;\n  }\n\n  emitRangeExpression(node, context) {\n    this.requireRuntime('range');\n    const wrapIfNeeded = (subNode, code) => {\n      if (!subNode) return code;\n      const needsParens = new Set([\n        'BinaryExpression',\n        'LogicalExpression',\n        'ConditionalExpression',\n        'AssignmentExpression',\n        'RangeExpression'\n      ]);\n      return needsParens.has(subNode.type) ? `(${code})` : code;\n    };\n    const start = this.emitExpression(node.start, context);\n    const end = this.emitExpression(node.end, context);\n    const startCode = wrapIfNeeded(node.start, start);\n    const endCode = wrapIfNeeded(node.end, end);\n    const exclusiveFlag = node.exclusive ? 'true' : 'false';\n    return `__rubyRange(${startCode}, ${endCode}, ${exclusiveFlag})`;\n  }\n\n  emitMethodDefinition(node, context = {}) {\n    const scope = this.scopeInfo.get(node);\n    const indent = this.indent();\n    const isStatic = context.inClass && node.target && node.target.type === 'SelfExpression';\n    const isConstructor = !isStatic && context.inClass && node.id.name === 'initialize';\n    const methodName = isConstructor ? 'constructor' : node.id.name;\n    const parameterAnalysis = this.prepareMethodParameters(node.params, scope, { usesYield: !!node.usesYield });\n    const paramsCode = parameterAnalysis.paramSignature.join(', ');\n    let header;\n    const isTopLevelMethod = !context.inClass && !context.inModule && !context.singletonTarget && !context.currentClassName;\n\n    if (context.inClass) {\n      if (isConstructor) {\n        header = `${indent}${methodName}(${paramsCode})`;\n      } else {\n        const methodKey = this.isValidMethodName(methodName) ? methodName : `[${this.quote(methodName)}]`;\n        const prefix = isStatic ? 'static ' : '';\n        header = `${indent}${prefix}${methodKey}(${paramsCode})`;\n      }\n    } else {\n      if (this.isValidMethodName(methodName)) {\n        header = `${indent}function ${methodName}(${paramsCode})`;\n      } else {\n        const tempName = this.generateUniqueId('__method');\n        header = `${indent}const ${tempName} = function(${paramsCode})`;\n      }\n    }\n\n    const allowImplicitReturn = !(context.inClass && methodName === 'constructor');\n    const body = this.emitFunctionBody(\n      node.body,\n      {\n        ...context,\n        scopeNode: node,\n        scopeStack: [node, ...(context.scopeStack || [])],\n        inFunction: true,\n        allowImplicitReturn,\n        methodType: isStatic ? 'static' : (isTopLevelMethod ? 'instance' : 'instance'),\n        topLevelMethod: isTopLevelMethod,\n        blockParamName: parameterAnalysis.blockParamName,\n        optionalParams: parameterAnalysis.optionalParams,\n        blockFromRest: parameterAnalysis.blockFromRest,\n        methodBlockInfo: parameterAnalysis.blockFromRest,\n        currentMethodName: methodName,\n        ...(parameterAnalysis.genericInfo ? { genericArgsInfo: parameterAnalysis.genericInfo } : {})\n      },\n      scope\n    );\n    let result = `${header} ${body}`;\n    if (isTopLevelMethod && this.isValidMethodName(methodName)) {\n      result += `\\n${indent}if (typeof globalThis !== \"undefined\") { globalThis.${methodName} = ${methodName}; }`;\n    }\n    return result;\n  }\n\n  emitFunctionBody(bodyNode, context, scope) {\n    let code = '{\\n';\n    this.indentLevel += 1;\n\n    const lines = [];\n    if (scope) {\n      for (const name of [...scope.hoisted].sort()) {\n        const safeName = this.getRenamedName(scope, name);\n        lines.push(this.indent() + `let ${safeName};`);\n      }\n    }\n\n    if (context.genericArgsInfo) {\n      const setup = this.buildGenericArgsHandling(context.genericArgsInfo, context);\n      lines.push(...setup.lines);\n      if (setup.forwardingInfo) {\n        context.forwardingInfo = setup.forwardingInfo;\n      }\n    }\n\n    if (context.optionalParams && context.optionalParams.length) {\n      for (const param of context.optionalParams) {\n        const defaultValue = this.emitExpression(param.default, context);\n        lines.push(this.indent() + `if (${param.name} === undefined) ${param.name} = ${defaultValue};`);\n      }\n    }\n\n    if (context.blockFromRest && context.blockFromRest.rest && context.blockFromRest.block) {\n      const restName = context.blockFromRest.rest;\n      const blockName = context.blockFromRest.block;\n      const candidate = this.generateUniqueId('__blockCandidate');\n      const candidateDecl = `${candidate}`;\n      const blockCheck = `typeof ${candidateDecl} === 'function'`;\n      lines.push(this.indent() + `const ${candidateDecl} = ${restName}.length ? ${restName}[${restName}.length - 1] : undefined;`);\n      lines.push(this.indent() + `const ${blockName} = ${blockCheck} ? ${candidateDecl} : undefined;`);\n      lines.push(this.indent() + `if (${blockCheck}) ${restName}.pop();`);\n    }\n\n    for (let index = 0; index < bodyNode.body.length; index += 1) {\n      const statement = bodyNode.body[index];\n      const isTail = index === bodyNode.body.length - 1;\n      const stmtContext = { ...context, isTail };\n      delete stmtContext.blockFromRest;\n      delete stmtContext.optionalParams;\n      delete stmtContext.genericArgsInfo;\n      const stmt = this.emitStatement(statement, stmtContext);\n      if (stmt) lines.push(stmt);\n    }\n\n    this.indentLevel -= 1;\n    if (lines.length) {\n      code += lines.join('\\n') + '\\n' + this.indent() + '}';\n    } else {\n      code += this.indent() + '}';\n    }\n    return code;\n  }\n\n  buildGenericArgsHandling(info, context) {\n    const lines = [];\n    const indent = this.indent();\n    const argsName = info.rawArgsName;\n\n    const forwardingInfo = {};\n    const needsBlock = !!info.blockParamName || info.usesYield || info.forwarding;\n    const blockVarName = info.blockParamName || (info.usesYield || info.forwarding ? '__block' : null);\n\n    if (needsBlock) {\n      const candidate = this.generateUniqueId('__blockCandidate');\n      lines.push(`${indent}const ${candidate} = ${argsName}.length ? ${argsName}[${argsName}.length - 1] : undefined;`);\n      lines.push(`${indent}const ${blockVarName} = typeof ${candidate} === 'function' ? ${candidate} : undefined;`);\n      lines.push(`${indent}if (typeof ${candidate} === 'function') ${argsName}.pop();`);\n      context.blockParamName = blockVarName;\n      forwardingInfo.blockName = blockVarName;\n    }\n\n    const hasExplicitKeywords = info.keywordRequired.length > 0 || info.keywordOptional.length > 0 || !!info.keywordRest;\n    const needsKeywordHandling = hasExplicitKeywords || info.forwarding;\n    let keywordVarName = null;\n    if (needsKeywordHandling) {\n      keywordVarName = info.keywordVarName || this.generateUniqueId('__kwargs');\n      info.keywordVarName = keywordVarName;\n      const candidate = this.generateUniqueId('__kwCandidate');\n      const baseValue = hasExplicitKeywords ? '{}' : 'undefined';\n      lines.push(`${indent}let ${keywordVarName} = ${baseValue};`);\n      lines.push(`${indent}if (${argsName}.length) {`);\n      lines.push(`${indent}  const ${candidate} = ${argsName}[${argsName}.length - 1];`);\n      lines.push(`${indent}  if (${candidate} && typeof ${candidate} === 'object' && !Array.isArray(${candidate})) {`);\n      lines.push(`${indent}    ${keywordVarName} = ${candidate};`);\n      lines.push(`${indent}    ${argsName}.pop();`);\n      lines.push(`${indent}  } else if (${hasExplicitKeywords ? 'true' : 'false'}) {`);\n      if (hasExplicitKeywords) {\n        lines.push(`${indent}    ${keywordVarName} = {};`);\n      }\n      lines.push(`${indent}  } else {`);\n      lines.push(`${indent}    ${keywordVarName} = undefined;`);\n      lines.push(`${indent}  }`);\n      lines.push(`${indent}}`);\n      if (hasExplicitKeywords) {\n        lines.push(`${indent}if (${keywordVarName} === undefined) ${keywordVarName} = {};`);\n      }\n      forwardingInfo.keywordName = keywordVarName;\n    }\n\n    const positionalAssignments = info.positional || [];\n    for (const entry of positionalAssignments) {\n      lines.push(`${indent}const ${entry.name} = ${argsName}.length ? ${argsName}.shift() : undefined;`);\n    }\n\n    const optionalAssignments = info.optional || [];\n    for (const entry of optionalAssignments) {\n      const defaultCode = this.emitExpression(entry.default, context);\n      lines.push(`${indent}let ${entry.name} = ${argsName}.length ? ${argsName}.shift() : undefined;`);\n      lines.push(`${indent}if (${entry.name} === undefined) ${entry.name} = ${defaultCode};`);\n    }\n\n    if (info.rest) {\n      lines.push(`${indent}const ${info.rest} = ${argsName}.splice(0);`);\n    } else if (!info.forwarding) {\n      lines.push(`${indent}if (${argsName}.length) {`);\n      lines.push(`${indent}  throw new Error(\"ArgumentError: wrong number of arguments\");`);\n      lines.push(`${indent}}`);\n    }\n\n    let usedKeysSet = null;\n    if (hasExplicitKeywords && (info.keywordRequired.length || info.keywordOptional.length || !info.keywordRest)) {\n      usedKeysSet = this.generateUniqueId('__kwUsed');\n      lines.push(`${indent}const ${usedKeysSet} = new Set();`);\n    }\n\n    const hasOwnCall = (keyLiteral) => `Object.prototype.hasOwnProperty.call(${keywordVarName}, ${keyLiteral})`;\n\n    for (const entry of info.keywordRequired || []) {\n      const keyLiteral = this.quote(entry.key);\n      lines.push(`${indent}if (${keywordVarName} === undefined || !${hasOwnCall(keyLiteral)}) {`);\n      lines.push(`${indent}  throw new Error(${this.quote(`ArgumentError: missing keyword: ${entry.key}`)});`);\n      lines.push(`${indent}}`);\n      lines.push(`${indent}const ${entry.name} = ${keywordVarName}[${keyLiteral}];`);\n      if (usedKeysSet) {\n        lines.push(`${indent}${usedKeysSet}.add(${keyLiteral});`);\n      }\n    }\n\n    for (const entry of info.keywordOptional || []) {\n      const keyLiteral = this.quote(entry.key);\n      const defaultCode = this.emitExpression(entry.default, context);\n      if (!hasExplicitKeywords) {\n        lines.push(`${indent}const ${entry.name} = ${defaultCode};`);\n      } else {\n        lines.push(`${indent}let ${entry.name} = ${keywordVarName} && ${hasOwnCall(keyLiteral)} ? ${keywordVarName}[${keyLiteral}] : ${defaultCode};`);\n      }\n      if (usedKeysSet) {\n        lines.push(`${indent}${usedKeysSet}.add(${keyLiteral});`);\n      }\n    }\n\n    if (info.keywordRest) {\n      lines.push(`${indent}const ${info.keywordRest} = {};`);\n      lines.push(`${indent}if (${keywordVarName} && typeof ${keywordVarName} === 'object') {`);\n      lines.push(`${indent}  for (const __key in ${keywordVarName}) {`);\n      lines.push(`${indent}    if (!Object.prototype.hasOwnProperty.call(${keywordVarName}, __key)) continue;`);\n      if (usedKeysSet) {\n        lines.push(`${indent}    if (${usedKeysSet}.has(__key)) continue;`);\n      }\n      lines.push(`${indent}    ${info.keywordRest}[__key] = ${keywordVarName}[__key];`);\n      lines.push(`${indent}  }`);\n      lines.push(`${indent}}`);\n    } else if (hasExplicitKeywords) {\n      const unknownKeys = this.generateUniqueId('__unknownKw');\n      lines.push(`${indent}const ${unknownKeys} = [];`);\n      lines.push(`${indent}for (const __key in ${keywordVarName}) {`);\n      lines.push(`${indent}  if (!Object.prototype.hasOwnProperty.call(${keywordVarName}, __key)) continue;`);\n      if (usedKeysSet) {\n        lines.push(`${indent}  if (${usedKeysSet}.has(__key)) continue;`);\n      }\n      lines.push(`${indent}  ${unknownKeys}.push(__key);`);\n      lines.push(`${indent}}`);\n      lines.push(`${indent}if (${unknownKeys}.length) {`);\n      lines.push(`${indent}  throw new Error(\"ArgumentError: unknown keyword\" + (${unknownKeys}.length > 1 ? \"s\" : \"\") + \": \" + ${unknownKeys}.join(', '));`);\n      lines.push(`${indent}}`);\n    }\n\n    if (info.forwarding) {\n      const forwardArgs = this.generateUniqueId('__forwardArgs');\n      lines.push(`${indent}const ${forwardArgs} = ${argsName}.slice();`);\n      forwardingInfo.positionalName = forwardArgs;\n      forwardingInfo.keywordName = keywordVarName || 'undefined';\n      forwardingInfo.blockName = blockVarName || 'undefined';\n    }\n\n    return { lines, forwardingInfo: info.forwarding ? forwardingInfo : null };\n  }\n\n  emitBlockFunction(block, context = {}, options = {}) {\n    const params = this.resolveBlockParameters(block);\n    const scope = this.scopeInfo.get(block);\n    const baseContext = { ...context };\n    delete baseContext.blockFromRest;\n    delete baseContext.optionalParams;\n    const forceImplicit = options.forceImplicitIdentifiers ?? baseContext.forceImplicitIdentifiers ?? false;\n    const fnContext = {\n      ...baseContext,\n      scopeNode: block,\n      scopeStack: [block, ...(baseContext.scopeStack || [])],\n      inFunction: true,\n      allowImplicitReturn: options.allowImplicitReturn !== undefined ? options.allowImplicitReturn : true,\n      forceImplicitIdentifiers: forceImplicit\n    };\n    const body = this.emitFunctionBody(block.body, fnContext, scope);\n    const paramList = params.join(', ');\n    const innerFunction = `function(${paramList}) ${body}`;\n    if (options.asFunction) {\n      return innerFunction;\n    }\n    const selfVar = this.generateUniqueId('__self');\n    const blockVar = this.generateUniqueId('__block');\n    const argsVar = this.generateUniqueId('__args');\n    const prevVar = this.generateUniqueId('__prev');\n    const lines = [];\n    lines.push('(() => {');\n    lines.push(`  let ${selfVar} = this;`);\n    lines.push(`  const ${blockVar} = function(...${argsVar}) {`);\n    lines.push(`    return (${innerFunction}).apply(${selfVar}, ${argsVar});`);\n    lines.push('  };');\n    lines.push(`  ${blockVar}.__rubyBind = (value) => {`);\n    lines.push(`    const ${prevVar} = ${selfVar};`);\n    lines.push(`    ${selfVar} = value;`);\n    lines.push('    return () => {');\n    lines.push(`      ${selfVar} = ${prevVar};`);\n    lines.push('    };');\n    lines.push('  };');\n    lines.push(`  return ${blockVar};`);\n    lines.push('})()');\n    return lines.join('\\n');\n  }\n\n  resolveBlockParameters(block) {\n    const scope = this.scopeInfo.get(block);\n    if (block.params && block.params.length) {\n      return block.params.map(param => this.getRenamedName(scope, param.name));\n    }\n    const inferred = this.inferImplicitParams(block.body);\n    if (scope) {\n      inferred.forEach(name => scope.declared.add(name));\n    }\n    return inferred;\n  }\n\n  inferImplicitParams(body) {\n    const names = new Set();\n    const visit = (node) => {\n      if (!node || typeof node !== 'object') return;\n      if (Array.isArray(node)) {\n        node.forEach(visit);\n        return;\n      }\n      switch (node.type) {\n        case 'Identifier':\n          if (/^_[0-9]+$/.test(node.name)) {\n            names.add(node.name);\n          }\n          break;\n        case 'LambdaExpression':\n          // do not traverse nested lambdas\n          return;\n        case 'BlockStatement':\n          node.body.forEach(visit);\n          return;\n        default:\n          for (const key in node) {\n            if (!Object.prototype.hasOwnProperty.call(node, key)) continue;\n            const value = node[key];\n            if (key === 'params') continue;\n            if (key === 'body' && node.type === 'LambdaExpression') continue;\n            visit(value);\n          }\n      }\n    };\n    visit(body);\n    return Array.from(names).sort((a, b) => {\n      const numA = parseInt(a.slice(1), 10);\n      const numB = parseInt(b.slice(1), 10);\n      return numA - numB;\n    });\n  }\n\n  emitClassDeclaration(node, context = {}) {\n    const indent = this.indent();\n    const extendsPart = node.superClass ? ` extends ${this.emitExpression(node.superClass, context)}` : '';\n    const className = node.id.name;\n    const { body, trailing } = this.emitClassBody(node.body, { ...context, currentClassName: className });\n    let code = `${indent}class ${className}${extendsPart} ${body}`;\n    if (trailing.length) {\n      code += '\\n' + trailing.map(line => `${indent}${line}`).join('\\n');\n    }\n    return code;\n  }\n\n  emitSingletonClassDeclaration(node, context = {}) {\n    const indent = this.indent();\n    let targetCode;\n    if (node.target && node.target.type === 'SelfExpression' && context.currentClassName) {\n      targetCode = context.currentClassName;\n    } else {\n      targetCode = this.emitExpression(node.target, context);\n    }\n    const targetVar = this.generateUniqueId('__singleton');\n    const lines = [`${indent}(() => {`];\n\n    this.indentLevel += 1;\n    const innerIndent = this.indent();\n    lines.push(`${innerIndent}const ${targetVar} = ${targetCode};`);\n    lines.push(`${innerIndent}if (${targetVar} == null) { return; }`);\n\n    const bodyContext = {\n      ...context,\n      singletonTarget: targetVar,\n      scopeStack: [node.body, ...(context.scopeStack || [])]\n    };\n\n    const bodyIndentLevel = this.indentLevel;\n    for (const statement of node.body.body) {\n      this.indentLevel = bodyIndentLevel;\n      if (statement.type === 'MethodDefinition') {\n        lines.push(this.emitSingletonMethodDefinition(statement, bodyContext));\n      } else {\n        const emitted = this.emitStatement(statement, bodyContext);\n        if (emitted) lines.push(emitted);\n      }\n    }\n\n    this.indentLevel = bodyIndentLevel - 1;\n    lines.push(`${this.indent()}})();`);\n    return lines.join('\\n');\n  }\n\n  emitSingletonMethodDefinition(node, context = {}) {\n    const scope = this.scopeInfo.get(node);\n    const indent = this.indent();\n    const methodName = node.id.name;\n    const parameterAnalysis = this.prepareMethodParameters(node.params, scope, { usesYield: !!node.usesYield });\n    const paramsCode = parameterAnalysis.paramSignature.join(', ');\n\n    const fnContext = {\n      ...context,\n      scopeNode: node,\n      scopeStack: [node, ...(context.scopeStack || [])],\n      inFunction: true,\n      allowImplicitReturn: true,\n      methodType: 'static',\n      blockParamName: parameterAnalysis.blockParamName,\n      optionalParams: parameterAnalysis.optionalParams,\n      blockFromRest: parameterAnalysis.blockFromRest,\n      currentMethodName: methodName,\n      ...(parameterAnalysis.genericInfo ? { genericArgsInfo: parameterAnalysis.genericInfo } : {})\n    };\n\n    const bodyCode = this.emitFunctionBody(node.body, fnContext, scope);\n    const accessor = this.isValidMethodName(methodName)\n      ? `${context.singletonTarget}.${methodName}`\n      : `${context.singletonTarget}[${this.quote(methodName)}]`;\n\n    return `${indent}${accessor} = function(${paramsCode}) ${bodyCode};`;\n  }\n\n  emitModuleMethodDefinition(node, context = {}) {\n    const scope = this.scopeInfo.get(node);\n    const moduleName = context.currentModuleName;\n    const indent = this.indent();\n    const methodName = node.id.name;\n    const parameterAnalysis = this.prepareMethodParameters(node.params, scope, { usesYield: !!node.usesYield });\n    const paramsCode = parameterAnalysis.paramSignature.join(', ');\n\n    const fnContext = {\n      ...context,\n      scopeNode: node,\n      scopeStack: [node, ...(context.scopeStack || [])],\n      inFunction: true,\n      allowImplicitReturn: true,\n      methodType: 'module',\n      blockParamName: parameterAnalysis.blockParamName,\n      optionalParams: parameterAnalysis.optionalParams,\n      blockFromRest: parameterAnalysis.blockFromRest,\n      currentMethodName: methodName,\n      ...(parameterAnalysis.genericInfo ? { genericArgsInfo: parameterAnalysis.genericInfo } : {})\n    };\n\n    const bodyCode = this.emitFunctionBody(node.body, fnContext, scope);\n    const accessor = this.isValidMethodName(methodName)\n      ? `${moduleName}.${methodName}`\n      : `${moduleName}[${this.quote(methodName)}]`;\n\n    return `${indent}${accessor} = function(${paramsCode}) ${bodyCode};`;\n  }\n\n  emitDefineSingletonMethodCall(node, context, info) {\n    const { objectCode, inlineBlockNode, blockCode, processedArgs } = info;\n    this.requireRuntime('defineSingleton');\n    const nameArg = node.arguments[0];\n    const nameExpr = this.resolveDefineSingletonName(nameArg, context);\n\n    let fnExpr = null;\n    if (inlineBlockNode) {\n      fnExpr = this.emitBlockFunction(inlineBlockNode, context, { forceImplicitIdentifiers: true, asFunction: true });\n    } else if (blockCode) {\n      fnExpr = blockCode;\n    } else if (node.arguments[1]) {\n      fnExpr = this.emitExpression(node.arguments[1], context);\n    } else if (processedArgs.length) {\n      fnExpr = processedArgs[processedArgs.length - 1].code;\n    }\n\n    if (!fnExpr) {\n      fnExpr = 'undefined';\n    }\n\n    const target = objectCode ?? this.emitExpression(node.callee.object, context);\n    return `__rubyDefineSingleton(${target}, ${nameExpr}, ${fnExpr})`;\n  }\n\n  resolveDefineSingletonName(node, context) {\n    if (!node) return 'undefined';\n    if (node.type === 'SymbolLiteral') {\n      return this.quote(node.name);\n    }\n    if (node.type === 'StringLiteral') {\n      return this.quote(node.value);\n    }\n    return this.emitExpression(node, context);\n  }\n\n  emitIncludeCall(node, context = {}) {\n    if (!node.arguments.length) return '';\n    const mixin = this.emitExpression(node.arguments[0], context);\n    const target = context.currentClassName || this.resolveImplicitCallReceiver(context);\n    this.requireRuntime('includeMixin');\n    return `__rubyInclude(${target}, ${mixin})`;\n  }\n\n  emitExtendCall(node, context = {}) {\n    if (!node.arguments.length) return '';\n    const mixin = this.emitExpression(node.arguments[0], context);\n    const target = context.currentClassName || this.resolveImplicitCallReceiver(context);\n    this.requireRuntime('extendMixin');\n    return `__rubyExtend(${target}, ${mixin})`;\n  }\n\n  emitPrependCall(node, context = {}) {\n    if (!node.arguments.length) return '';\n    const mixin = this.emitExpression(node.arguments[0], context);\n    const target = context.currentClassName || this.resolveImplicitCallReceiver(context);\n    this.requireRuntime('prependMixin');\n    return `__rubyPrepend(${target}, ${mixin})`;\n  }\n\n  emitModuleDeclaration(node, context = {}) {\n    const indent = this.indent();\n    const moduleName = node.id.name;\n    const lines = [`${indent}const ${moduleName} = {};`];\n    const moduleContext = { ...context, inModule: true, currentModuleName: moduleName };\n\n    this.indentLevel += 1;\n    for (const statement of node.body.body) {\n      let stmt;\n      if (statement.type === 'MethodDefinition') {\n        stmt = this.emitModuleMethodDefinition(statement, moduleContext);\n      } else {\n        stmt = this.emitStatement(statement, moduleContext);\n      }\n      if (stmt) lines.push(stmt);\n    }\n    this.indentLevel -= 1;\n\n    return lines.join('\\n');\n  }\n\n  emitUsingStatement(node) {\n    const indent = this.indent();\n    return `${indent}// using ${node.id.name}`;\n  }\n\n  emitClassBody(bodyNode, context) {\n    let code = '{\\n';\n    this.indentLevel += 1;\n    const lines = [];\n    const trailing = [];\n    const classScopeStack = [bodyNode, ...(context.scopeStack || [])];\n\n    for (const statement of bodyNode.body) {\n      if (statement.type === 'MethodDefinition') {\n        const stmtCode = this.emitMethodDefinition(statement, {\n          ...context,\n          inClass: true,\n          scopeNode: statement,\n          scopeStack: classScopeStack\n        });\n        if (stmtCode) lines.push(stmtCode);\n      } else {\n        const stmtCode = this.emitStatement(statement, {\n          ...context,\n          classLevel: true,\n          inClass: true,\n          scopeStack: classScopeStack\n        });\n        if (stmtCode) trailing.push(stmtCode.replace(/^\\s+/, ''));\n      }\n    }\n    this.indentLevel -= 1;\n    if (lines.length) {\n      code += lines.join('\\n') + '\\n' + this.indent() + '}';\n    } else {\n      code += this.indent() + '}';\n    }\n    return { body: code, trailing };\n  }\n\n  emitIfStatement(node, context = {}, options = {}) {\n    const indent = this.indent();\n    const keyword = options.isElseIf ? 'else if' : 'if';\n    const branchContext = context.isTail\n      ? context\n      : { ...context, allowImplicitReturn: false };\n    let code = `${indent}${keyword} (${this.emitExpression(node.test, context)}) ${this.emitBlockStatement(node.consequent, branchContext)}`;\n    if (node.alternate) {\n      if (node.alternate.type === 'IfStatement') {\n        code += '\\n' + this.emitIfStatement(node.alternate, context, { isElseIf: true });\n      } else {\n        code += '\\n' + indent + 'else ' + this.emitBlockStatement(node.alternate, branchContext);\n      }\n    }\n    return code;\n  }\n\n  emitWhileStatement(node, context = {}) {\n    const indent = this.indent();\n    const bodyContext = { ...context, allowImplicitReturn: false };\n    return `${indent}while (${this.emitExpression(node.test, context)}) ${this.emitBlockStatement(node.body, bodyContext)}`;\n  }\n\n  emitLoopStatement(node, context = {}) {\n    const indent = this.indent();\n    const bodyContext = { ...context, allowImplicitReturn: false };\n    return `${indent}while (true) ${this.emitBlockStatement(node.body, bodyContext)}`;\n  }\n\n  emitReturnStatement(node, context = {}) {\n    if (!node.argument) return 'return;';\n    return `return ${this.emitExpression(node.argument, context)};`;\n  }\n\n  emitBlockStatement(node, context = {}) {\n    let code = '{\\n';\n    this.indentLevel += 1;\n    const lines = [];\n    for (let index = 0; index < node.body.length; index += 1) {\n      const statement = node.body[index];\n      const isTail = index === node.body.length - 1;\n      const stmtContext = { ...context, isTail };\n      const stmt = this.emitStatement(statement, stmtContext);\n      if (stmt) lines.push(stmt);\n    }\n    this.indentLevel -= 1;\n    if (lines.length) {\n      code += lines.join('\\n') + '\\n' + this.indent() + '}';\n    } else {\n      code += this.indent() + '}';\n    }\n    return code;\n  }\n\n  emitCaseStatement(node, context = {}) {\n    if (!node.clauses.length) return '';\n    const indent = this.indent();\n    const lines = [];\n    const preludeLines = [];\n    const clauseInfos = [];\n\n    const hasPatternClause = node.clauses.some(clause => clause.type === 'PatternClause');\n    let valueReference = node.test ? this.emitCaseTestExpression(node.test, context) : null;\n\n    if (hasPatternClause && valueReference) {\n      const caseVar = this.generateUniqueId('__case');\n      preludeLines.push(`${indent}const ${caseVar} = ${valueReference};`);\n      valueReference = caseVar;\n    }\n\n    for (const clause of node.clauses) {\n      if (clause.type === 'PatternClause') {\n        const matcher = this.buildPatternMatcher(clause, valueReference ?? 'undefined', context, indent);\n        preludeLines.push(...matcher.setupLines);\n        const block = this.prependBlockLines(\n          this.emitBlockStatement(clause.body, context),\n          matcher.bindingLines\n        );\n        clauseInfos.push({ condition: matcher.condition, block });\n      } else {\n        const condition = this.emitCaseCondition(valueReference, clause, context);\n        const block = this.emitBlockStatement(clause.body, context);\n        clauseInfos.push({ condition, block });\n      }\n    }\n\n    lines.push(...preludeLines);\n\n    clauseInfos.forEach((info, index) => {\n      const keyword = index === 0 ? 'if' : 'else if';\n      lines.push(`${indent}${keyword} (${info.condition}) ${info.block}`);\n    });\n\n    if (node.alternate) {\n      lines.push(`${indent}else ${this.emitBlockStatement(node.alternate, context)}`);\n    }\n\n    return lines.join('\\n');\n  }\n\n  emitCaseCondition(valueReference, clause, context) {\n    const expressions = clause.tests.map(test => this.emitExpression(test, context));\n    if (valueReference) {\n      return expressions.map(expr => `${valueReference} === ${expr}`).join(' || ');\n    }\n    if (expressions.length === 0) return 'true';\n    return expressions.join(' || ');\n  }\n\n  emitCaseTestExpression(node, context) {\n    if (!node) return null;\n    if (node.type === 'Identifier') {\n      return node.name;\n    }\n    return this.emitExpression(node, context);\n  }\n\n  buildPatternMatcher(clause, valueExpression, context, baseIndent) {\n    const matchVar = this.generateUniqueId('__pattern');\n    const step = ' '.repeat(this.indentSize);\n    const indent1 = baseIndent + step;\n    const indent2 = indent1 + step;\n    const bindingsVar = this.generateUniqueId('__bindings');\n    const clauseScope = this.scopeInfo.get(clause.body);\n    const guardContext = {\n      ...context,\n      scopeStack: [clause.body, ...(context.scopeStack || [])]\n    };\n\n    const patternState = {\n      baseIndent,\n      indent1,\n      indent2,\n      indentStep: step,\n      bindingsVar,\n      clauseScope,\n      guardContext,\n      bindingInfos: [],\n      context,\n      lines: []\n    };\n\n    patternState.lines.push(`${indent1}if (__value == null) return null;`);\n    patternState.lines.push(`${indent1}const ${bindingsVar} = {};`);\n\n    const success = this.appendPattern(clause.pattern, '__value', patternState);\n\n    if (!success) {\n      return {\n        setupLines: [`${baseIndent}const ${matchVar} = null;`],\n        condition: matchVar,\n        bindingLines: []\n      };\n    }\n\n    if (clause.guard) {\n      const guardCode = this.emitExpression(clause.guard.condition, guardContext);\n      if (clause.guard.negated) {\n        patternState.lines.push(`${indent1}if (${guardCode}) return null;`);\n      } else {\n        patternState.lines.push(`${indent1}if (!(${guardCode})) return null;`);\n      }\n    }\n\n    patternState.lines.push(`${indent1}return ${bindingsVar};`);\n\n    const setupLines = [\n      `${baseIndent}const ${matchVar} = (() => {`,\n      `${indent1}const __value = ${valueExpression};`,\n      ...patternState.lines,\n      `${baseIndent}})();`\n    ];\n\n    const bindingIndent = baseIndent + step;\n    const bindingLines = patternState.bindingInfos.map(info => `${bindingIndent}const ${info.safeName} = ${matchVar}.${info.safeName};`);\n\n    return { setupLines, condition: matchVar, bindingLines };\n  }\n\n  appendPattern(pattern, valueVar, state) {\n    if (!pattern || typeof pattern !== 'object') return false;\n    switch (pattern.type) {\n      case 'HashPattern':\n        return this.appendHashPattern(pattern, valueVar, state);\n      case 'ArrayPattern':\n        return this.appendArrayPattern(pattern, valueVar, state);\n      case 'Identifier': {\n        const safeName = this.getRenamedName(state.clauseScope, pattern.name);\n        state.lines.push(`${state.indent1}const ${safeName} = ${valueVar};`);\n        state.lines.push(`${state.indent1}${state.bindingsVar}.${safeName} = ${safeName};`);\n        state.bindingInfos.push({ safeName });\n        return true;\n      }\n      default:\n        return false;\n    }\n  }\n\n  appendHashPattern(pattern, valueVar, state) {\n    state.lines.push(`${state.indent1}if (typeof ${valueVar} !== 'object') return null;`);\n    for (const entry of pattern.entries) {\n      const accessVar = this.generateUniqueId('__prop');\n      const foundVar = this.generateUniqueId('__found');\n      const keys = this.resolvePatternKeyExpressions(entry.key, state.context);\n      state.lines.push(`${state.indent1}let ${foundVar} = false;`);\n      state.lines.push(`${state.indent1}let ${accessVar};`);\n      for (const expr of keys) {\n        state.lines.push(`${state.indent1}if (!${foundVar} && Object.prototype.hasOwnProperty.call(${valueVar}, ${expr})) {`);\n        state.lines.push(`${state.indent2}${foundVar} = true;`);\n        state.lines.push(`${state.indent2}${accessVar} = ${valueVar}[${expr}];`);\n        state.lines.push(`${state.indent1}}`);\n      }\n      state.lines.push(`${state.indent1}if (!${foundVar}) return null;`);\n\n      if (entry.value) {\n        if (entry.value.type === 'PinExpression') {\n          const pinExpr = this.emitExpression(entry.value.expression, state.context);\n          state.lines.push(`${state.indent1}if (${accessVar} !== ${pinExpr}) return null;`);\n        } else {\n          return false;\n        }\n      }\n\n      if (entry.binding && entry.binding.name) {\n        const safeName = this.getRenamedName(state.clauseScope, entry.binding.name);\n        state.lines.push(`${state.indent1}const ${safeName} = ${accessVar};`);\n        state.lines.push(`${state.indent1}${state.bindingsVar}.${safeName} = ${safeName};`);\n        state.bindingInfos.push({ safeName });\n      }\n    }\n    return true;\n  }\n\n  appendArrayPattern(pattern, valueVar, state) {\n    state.lines.push(`${state.indent1}if (!Array.isArray(${valueVar})) return null;`);\n    const required = pattern.elements.length;\n    if (pattern.rest) {\n      state.lines.push(`${state.indent1}if (${valueVar}.length < ${required}) return null;`);\n    } else {\n      state.lines.push(`${state.indent1}if (${valueVar}.length !== ${required}) return null;`);\n    }\n\n    for (let index = 0; index < pattern.elements.length; index += 1) {\n      const element = pattern.elements[index];\n      const elementVar = this.generateUniqueId('__elem');\n      state.lines.push(`${state.indent1}const ${elementVar} = ${valueVar}[${index}];`);\n      if (!element) continue;\n      if (element.type === 'Identifier') {\n        const safeName = this.getRenamedName(state.clauseScope, element.name);\n        state.lines.push(`${state.indent1}const ${safeName} = ${elementVar};`);\n        state.lines.push(`${state.indent1}${state.bindingsVar}.${safeName} = ${safeName};`);\n        state.bindingInfos.push({ safeName });\n        continue;\n      }\n      if (element.type === 'PinExpression') {\n        const pinExpr = this.emitExpression(element.expression, state.context);\n        state.lines.push(`${state.indent1}if (${elementVar} !== ${pinExpr}) return null;`);\n        continue;\n      }\n      return false;\n    }\n\n    if (pattern.rest && pattern.rest.name) {\n      const startIndex = pattern.elements.length;\n      const safeName = this.getRenamedName(state.clauseScope, pattern.rest.name);\n      state.lines.push(`${state.indent1}const ${safeName} = ${valueVar}.slice(${startIndex});`);\n      state.lines.push(`${state.indent1}${state.bindingsVar}.${safeName} = ${safeName};`);\n      state.bindingInfos.push({ safeName });\n    }\n\n    return true;\n  }\n\n  resolvePatternKeyExpressions(keyNode, context) {\n    if (!keyNode) return ['undefined'];\n    switch (keyNode.type) {\n      case 'SymbolLiteral': {\n        const literal = this.quote(keyNode.name);\n        const symbolExpr = `Symbol.for(${literal})`;\n        return Array.from(new Set([literal, symbolExpr]));\n      }\n      case 'Identifier': {\n        const literal = this.quote(keyNode.name);\n        const symbolExpr = `Symbol.for(${literal})`;\n        return Array.from(new Set([literal, symbolExpr]));\n      }\n      case 'StringLiteral':\n        return [this.quote(keyNode.value)];\n      default:\n        return [this.emitExpression(keyNode, context)];\n    }\n  }\n\n  convertFunctionToArrow(fnSource) {\n    if (typeof fnSource !== 'string') return fnSource;\n    if (!/^function\\s*\\(/.test(fnSource)) return fnSource;\n    const paramsConverted = fnSource.replace(/^function\\s*\\(/, '(');\n    return paramsConverted.replace(/\\)\\s*{/, ') => {');\n  }\n\n  isRubyExceptionConstant(name) {\n    const known = new Set([\n      'ArgumentError', 'RuntimeError', 'StandardError', 'TypeError', 'NameError', 'NoMethodError',\n      'IndexError', 'KeyError', 'RangeError', 'IOError', 'EOFError', 'SystemCallError'\n    ]);\n    return known.has(name);\n  }\n\n  prependBlockLines(block, lines) {\n    if (!lines.length) return block;\n    const parts = block.split('\\n');\n    parts.splice(1, 0, ...lines);\n    return parts.join('\\n');\n  }\n\n  collectPattern(pattern, scope) {\n    if (!pattern || typeof pattern !== 'object') return;\n    switch (pattern.type) {\n      case 'HashPattern':\n        for (const entry of pattern.entries) {\n          if (entry.binding && entry.binding.name) {\n            scope.declared.add(entry.binding.name);\n            this.registerReservedName(scope, entry.binding.name);\n          }\n          if (entry.value) this.collectPattern(entry.value, scope);\n        }\n        break;\n      case 'ArrayPattern':\n        for (const element of pattern.elements) {\n          this.collectPattern(element, scope);\n        }\n        if (pattern.rest && pattern.rest.name) {\n          scope.declared.add(pattern.rest.name);\n          this.registerReservedName(scope, pattern.rest.name);\n        }\n        break;\n      case 'PinExpression':\n        this.collectNode(pattern.expression, scope);\n        break;\n      case 'Identifier':\n        scope.declared.add(pattern.name);\n        this.registerReservedName(scope, pattern.name);\n        break;\n      default:\n        this.collectNode(pattern, scope);\n        break;\n    }\n  }\n\n  splitInterpolatedString(value) {\n    const parts = [];\n    let cursor = 0;\n    while (cursor < value.length) {\n      const start = value.indexOf('#{', cursor);\n      if (start === -1) {\n        const text = value.slice(cursor);\n        if (text.length) parts.push({ type: 'text', value: text });\n        break;\n      }\n      const text = value.slice(cursor, start);\n      if (text.length) parts.push({ type: 'text', value: text });\n\n      let depth = 1;\n      let index = start + 2;\n      let expression = '';\n      while (index < value.length && depth > 0) {\n        const char = value[index];\n        if (char === '{') {\n          depth += 1;\n          expression += char;\n        } else if (char === '}') {\n          depth -= 1;\n          if (depth === 0) {\n            index += 1;\n            break;\n          }\n          expression += char;\n        } else {\n          expression += char;\n        }\n        index += 1;\n      }\n\n      if (depth !== 0) {\n        throw new Error('Unterminated interpolation in string literal');\n      }\n\n      parts.push({ type: 'expression', value: expression.trim() });\n      cursor = index;\n    }\n    return parts;\n  }\n\n  escapeTemplateText(text) {\n    return text\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/`/g, '\\\\`')\n      .replace(/\\$/g, '\\\\$');\n  }\n\n  parseEmbeddedExpression(fragment) {\n    const tokenizer = new Tokenizer(fragment);\n    const tokens = tokenizer.tokenize();\n    const parser = new Parser(tokens);\n    const ast = parser.parse();\n    if (ast.body.length !== 1) {\n      throw new Error('Interpolation expressions must resolve to a single expression');\n    }\n    const statement = ast.body[0];\n    if (statement.type !== 'ExpressionStatement') {\n      throw new Error('Interpolation expressions must be valid Ruby expressions');\n    }\n    return statement.expression;\n  }\n\n  mapBinaryOperator(op) {\n    if (op === '==') return '===';\n    if (op === '!=') return '!==';\n    return op;\n  }\n\n  getStringBangInfo(name) {\n    const mapping = {\n      'capitalize!': { helper: '__rubyCapitalizeBang', runtime: 'capitalizeBang', dependencies: ['capitalize'] },\n      'reverse!': { helper: '__rubyReverseBang', runtime: 'reverseBang' },\n      'upcase!': { helper: '__rubyUpcaseBang', runtime: 'upcaseBang' },\n      'downcase!': { helper: '__rubyDowncaseBang', runtime: 'downcaseBang' },\n      'strip!': { helper: '__rubyStripBang', runtime: 'stripBang', dependencies: ['strip'] },\n      'swapcase!': { helper: '__rubySwapcaseBang', runtime: 'swapcaseBang', dependencies: ['swapcase'] }\n    };\n    return mapping[name] || null;\n  }\n\n  generateUniqueId(prefix = '__temp') {\n    this.uniqueIdCounter += 1;\n    return `${prefix}${this.uniqueIdCounter}`;\n  }\n\n  quote(value) {\n    const escaped = value\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\"/g, '\\\\\"');\n    return `\"${escaped}\"`;\n  }\n\n  isReservedIdentifier(name) {\n    return this.reservedWords.has(name);\n  }\n\n  isValidMethodName(name) {\n    if (!name) return false;\n    if (!/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name)) return false;\n    return !this.isReservedIdentifier(name);\n  }\n\n  registerReservedName(scope, name) {\n    if (!scope || !name || !this.isReservedIdentifier(name)) return;\n    if (!scope.renamed) scope.renamed = new Map();\n    if (scope.renamed.has(name)) return;\n    let suffix = '_';\n    let candidate = `${name}${suffix}`;\n    const taken = new Set(scope.renamed ? [...scope.renamed.values()] : []);\n    while (this.isReservedIdentifier(candidate) || taken.has(candidate)) {\n      suffix += '_';\n      candidate = `${name}${suffix}`;\n    }\n    scope.renamed.set(name, candidate);\n  }\n\n  reserveName(scope, name) {\n    if (!scope || !name) return;\n    if (!scope.renamed) scope.renamed = new Map();\n    if (scope.renamed.has(name)) return scope.renamed.get(name);\n    const taken = new Set([\n      ...(scope.declared ? scope.declared : []),\n      ...(scope.hoisted ? scope.hoisted : []),\n      ...(scope.renamed ? scope.renamed.values() : [])\n    ]);\n    let index = 0;\n    let candidate;\n    do {\n      candidate = index === 0 ? `__${name}` : `__${name}${index}`;\n      index += 1;\n    } while (taken.has(candidate) || this.isReservedIdentifier(candidate));\n\n    scope.renamed.set(name, candidate);\n    if (scope.declared && scope.declared.has(name)) {\n      scope.declared.delete(name);\n      scope.declared.add(candidate);\n    }\n    if (scope.hoisted && scope.hoisted.has(name)) {\n      scope.hoisted.delete(name);\n      scope.hoisted.add(candidate);\n    }\n    return candidate;\n  }\n\n  getRenamedName(scope, name) {\n    if (!scope || !name) return name;\n    if (scope.renamed && scope.renamed.has(name)) {\n      return scope.renamed.get(name);\n    }\n    return name;\n  }\n\n  isIdentifierDeclared(name, context = {}) {\n    if (!name) return false;\n    const stack = [];\n    if (context.scopeStack && context.scopeStack.length) {\n      stack.push(...context.scopeStack);\n    }\n    if (context.scopeNode && !stack.includes(context.scopeNode)) {\n      stack.push(context.scopeNode);\n    }\n    for (const scopeNode of stack) {\n      const scope = this.scopeInfo.get(scopeNode);\n      if (scope && scope.declared && scope.declared.has(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isDeclaredInScopeChain(name, scope) {\n    let current = scope;\n    while (current) {\n      if (current.declared) {\n        if (current.declared.has(name)) return true;\n        if (current.renamed && current.renamed.has(name)) {\n          const mapped = current.renamed.get(name);\n          if (current.declared.has(mapped)) return true;\n        }\n      }\n      current = current.parent ?? null;\n    }\n    return false;\n  }\n\n  isMethodName(name, context = {}) {\n    if (!name) return false;\n    const stack = [];\n    if (context.scopeStack && context.scopeStack.length) {\n      stack.push(...context.scopeStack);\n    }\n    if (context.scopeNode && !stack.includes(context.scopeNode)) {\n      stack.push(context.scopeNode);\n    }\n    for (const scopeNode of stack) {\n      const scope = this.scopeInfo.get(scopeNode);\n      if (scope && scope.methods && scope.methods.has(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  resolveImplicitCallReceiver(context = {}) {\n    if (context && typeof context.implicitReceiver === 'string') {\n      return context.implicitReceiver;\n    }\n    if (context && context.topLevelMethod) {\n      return 'globalThis';\n    }\n    if (context && context.scopeNode && context.scopeNode.type === 'Program') {\n      return 'globalThis';\n    }\n    if (context.methodType === 'static' && context.currentClassName) {\n      return 'this';\n    }\n    if (context.classLevel && context.currentClassName) {\n      return context.currentClassName;\n    }\n    return 'this';\n  }\n\n  isFastMode() {\n    return this.fastMode;\n  }\n\n  isSafeJsIdentifier(name) {\n    if (!name) return false;\n    return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);\n  }\n\n  getStaticPropertyName(node) {\n    if (!node || typeof node !== 'object') return null;\n    if (node.type === 'Identifier') return node.name;\n    if (node.type === 'StringLiteral') return node.value;\n    if (node.type === 'SymbolLiteral') return node.name;\n    return null;\n  }\n\n  isManifestlyNumeric(node) {\n    if (!node || typeof node !== 'object') return false;\n    if (node.type === 'NumericLiteral') return true;\n    if (node.type === 'UnaryExpression' && ['+', '-'].includes(node.operator)) {\n      return this.isManifestlyNumeric(node.argument);\n    }\n    return false;\n  }\n\n  wrapBinaryOperand(node, code) {\n    if (!node || typeof node !== 'object') return code;\n    if (node.type === 'LogicalExpression') {\n      return `(${code})`;\n    }\n    return code;\n  }\n\n  resolveIdentifierName(name, context = {}) {\n    if (!name) return name;\n    const stack = context.scopeStack && context.scopeStack.length\n      ? context.scopeStack\n      : (context.scopeNode ? [context.scopeNode] : []);\n    for (const scopeNode of stack) {\n      const scope = this.scopeInfo.get(scopeNode);\n      if (scope && scope.renamed && scope.renamed.has(name)) {\n        return scope.renamed.get(name);\n      }\n    }\n    return name;\n  }\n\n  formatObjectKey(keyNode) {\n    if (!keyNode) return 'undefined';\n    switch (keyNode.type) {\n      case 'Identifier':\n        return keyNode.name;\n      case 'StringLiteral':\n        return this.quote(keyNode.value);\n      case 'SymbolLiteral':\n        return keyNode.name;\n      default:\n        return this.emitExpression(keyNode);\n    }\n  }\n\n  indent() {\n    return ' '.repeat(this.indentLevel * this.indentSize);\n  }\n\n  collectProgram(node) {\n    if (this.scopeInfo.has(node)) return;\n    const scope = this.createScope(null);\n    scope.kind = 'program';\n    this.scopeInfo.set(node, scope);\n    for (const statement of node.body) {\n      this.collectNode(statement, scope);\n    }\n  }\n\n  collectMethod(node, parentScope = null) {\n    if (this.scopeInfo.has(node)) return;\n    if (parentScope && node.id && node.id.name && this.isValidMethodName(node.id.name)) {\n      const name = node.id.name;\n      if ((parentScope.declared && parentScope.declared.has(name)) || (parentScope.hoisted && parentScope.hoisted.has(name))) {\n        this.reserveName(parentScope, name);\n      }\n      if (parentScope.kind === 'program') {\n        parentScope.declared.add(name);\n      }\n      if (parentScope.methods) {\n        parentScope.methods.add(name);\n      }\n    } else if (parentScope && parentScope.methods && node.id && node.id.name) {\n      parentScope.methods.add(node.id.name);\n    }\n    const scope = this.createScope(parentScope);\n    for (const param of node.params) {\n      if (!param) continue;\n      if (param.name) {\n        scope.declared.add(param.name);\n        this.registerReservedName(scope, param.name);\n      }\n      if (param.type === 'OptionalParameter' && param.default) {\n        this.collectNode(param.default, scope);\n      }\n      if (param.type === 'KeywordOptionalParameter' && param.default) {\n        this.collectNode(param.default, scope);\n      }\n    }\n    if (node.usesYield && !node.params.some(param => param.type === 'BlockParameter')) {\n      scope.declared.add('__block');\n    }\n    this.scopeInfo.set(node, scope);\n    this.collectNode(node.body, scope);\n  }\n\n  createScope(parent = null) {\n    return { declared: new Set(), hoisted: new Set(), renamed: new Map(), methods: new Set(), parent };\n  }\n\n  collectNode(node, scope) {\n    if (!node || typeof node !== 'object') return;\n    switch (node.type) {\n      case 'Program':\n        this.collectProgram(node);\n        break;\n      case 'BlockStatement':\n        for (const stmt of node.body) this.collectNode(stmt, scope);\n        break;\n      case 'ExpressionStatement':\n        this.collectNode(node.expression, scope);\n        break;\n      case 'AssignmentExpression':\n        this.recordAssignment(node.left, scope);\n        this.collectNode(node.right, scope);\n        break;\n      case 'MultiAssignmentExpression':\n        if (Array.isArray(node.targets)) {\n          for (const target of node.targets) {\n            this.recordAssignment(target, scope);\n          }\n        }\n        this.collectNode(node.right, scope);\n        break;\n      case 'BinaryExpression':\n      case 'LogicalExpression':\n        this.collectNode(node.left, scope);\n        this.collectNode(node.right, scope);\n        break;\n      case 'UnaryExpression':\n        this.collectNode(node.argument, scope);\n        break;\n      case 'CallExpression':\n        this.collectNode(node.callee, scope);\n        for (const arg of node.arguments) this.collectNode(arg, scope);\n        if (node.block) this.collectBlock(node.block, scope);\n        break;\n      case 'MemberExpression':\n        this.collectNode(node.object, scope);\n        if (node.computed) this.collectNode(node.property, scope);\n        break;\n      case 'OptionalMemberExpression':\n        this.collectNode(node.object, scope);\n        if (node.computed) this.collectNode(node.property, scope);\n        break;\n      case 'ArrayExpression':\n        for (const element of node.elements) this.collectNode(element, scope);\n        break;\n      case 'HashExpression':\n        for (const prop of node.properties) this.collectNode(prop.value, scope);\n        break;\n      case 'IfStatement':\n        this.collectNode(node.test, scope);\n        this.collectNode(node.consequent, scope);\n        if (node.alternate) this.collectNode(node.alternate, scope);\n        break;\n      case 'WhileStatement':\n        this.collectNode(node.test, scope);\n        this.collectNode(node.body, scope);\n        break;\n      case 'LoopStatement':\n        this.collectNode(node.body, scope);\n        break;\n      case 'ReturnStatement':\n        if (node.argument) this.collectNode(node.argument, scope);\n        break;\n      case 'ConditionalExpression':\n        this.collectNode(node.test, scope);\n        this.collectNode(node.consequent, scope);\n        this.collectNode(node.alternate, scope);\n        break;\n      case 'CaseStatement':\n        if (node.test) this.collectNode(node.test, scope);\n        for (const clause of node.clauses) {\n          if (clause.type === 'PatternClause') {\n            this.collectPattern(clause.pattern, scope);\n          } else if (clause.tests) {\n            for (const test of clause.tests) this.collectNode(test, scope);\n          }\n          this.collectNode(clause.body, scope);\n        }\n        if (node.alternate) this.collectNode(node.alternate, scope);\n        break;\n      case 'MethodDefinition':\n        this.collectMethod(node, scope);\n        break;\n      case 'LambdaExpression':\n        this.collectLambda(node, scope);\n        break;\n      case 'SingletonClassDeclaration':\n        this.collectNode(node.target, scope);\n        this.collectNode(node.body, scope);\n        break;\n      case 'BeginRescueExpression':\n        this.collectNode(node.body, scope);\n        if (node.rescues) {\n          for (const clause of node.rescues) {\n            if (clause.binding && clause.binding.name) {\n              scope.declared.add(clause.binding.name);\n              this.registerReservedName(scope, clause.binding.name);\n            }\n            for (const ex of clause.exceptions || []) {\n              this.collectNode(ex, scope);\n            }\n            this.collectNode(clause.body, scope);\n          }\n        }\n        if (node.elseBody) this.collectNode(node.elseBody, scope);\n        if (node.ensureBody) this.collectNode(node.ensureBody, scope);\n        break;\n      case 'ToProcExpression':\n        this.collectNode(node.argument, scope);\n        break;\n      case 'BlockPassExpression':\n        this.collectNode(node.expression, scope);\n        break;\n      case 'YieldExpression':\n        for (const argument of node.arguments) this.collectNode(argument, scope);\n        break;\n      case 'ClassDeclaration':\n        if (!this.scopeInfo.has(node.body)) {\n          const classScope = this.createScope(scope);\n          classScope.kind = 'class';\n          this.scopeInfo.set(node.body, classScope);\n          this.collectNode(node.body, classScope);\n        } else {\n          const classScope = this.scopeInfo.get(node.body);\n          this.collectNode(node.body, classScope);\n        }\n        break;\n      case 'ModuleDeclaration':\n        if (node.body) this.collectNode(node.body, scope);\n        break;\n      default:\n        break;\n    }\n  }\n\n  collectBlock(block, parentScope) {\n    if (!block || this.scopeInfo.has(block)) return;\n    const scope = this.createScope(parentScope);\n    for (const param of block.params) {\n      scope.declared.add(param.name);\n      this.registerReservedName(scope, param.name);\n    }\n    if (!block.params.length) {\n      const inferred = this.inferImplicitParams(block.body);\n      inferred.forEach(name => scope.declared.add(name));\n    }\n    this.scopeInfo.set(block, scope);\n    this.collectNode(block.body, scope);\n  }\n\n  collectLambda(node, parentScope) {\n    if (this.scopeInfo.has(node)) return;\n    const scope = this.createScope(parentScope);\n    for (const param of node.params) {\n      scope.declared.add(param.name);\n      this.registerReservedName(scope, param.name);\n    }\n    if (!node.params.length) {\n      const inferred = this.inferImplicitParams(node.body);\n      inferred.forEach(name => scope.declared.add(name));\n    }\n    this.scopeInfo.set(node, scope);\n    this.collectNode(node.body, scope);\n  }\n\n  recordAssignment(target, scope) {\n    if (!target || !scope) return;\n    if (target.type === 'Identifier') {\n      const original = target.name;\n      if (this.isDeclaredInScopeChain(original, scope.parent ?? null)) return;\n      if (!scope.renamed || !scope.renamed.has(original)) {\n        this.registerReservedName(scope, original);\n      }\n      const mapped = scope.renamed && scope.renamed.has(original)\n        ? scope.renamed.get(original)\n        : original;\n      if (!scope.declared.has(mapped)) {\n        scope.declared.add(mapped);\n        scope.hoisted.add(mapped);\n      }\n    } else if (target.type === 'MemberExpression') {\n      this.collectNode(target.object, scope);\n      if (target.computed) this.collectNode(target.property, scope);\n    }\n  }\n}\n\nmodule.exports = { Emitter };\n", "const { Tokenizer } = require('./tokenizer');\nconst { Parser } = require('./parser');\nconst { Emitter } = require('./emitter');\n\nfunction normalizeMode(mode) {\n  if (typeof mode !== 'string') return 'strict';\n  const lowered = mode.toLowerCase();\n  return lowered === 'fast' ? 'fast' : 'strict';\n}\n\nfunction transpile(source, options = {}) {\n  const tokenizer = new Tokenizer(source);\n  const tokens = tokenizer.tokenize();\n  const parser = new Parser(tokens);\n  const ast = parser.parse();\n  const mode = normalizeMode(options.mode);\n  const emitterOptions = { mode, ...(options.emitter || {}) };\n  const emitter = new Emitter(emitterOptions);\n  const code = emitter.emit(ast);\n  return { ast, code };\n}\n\nconst api = { transpile, Tokenizer, Parser, Emitter };\n\nconst browserGlobal = typeof window !== 'undefined'\n  ? window\n  : (typeof self !== 'undefined' ? self : null);\n\nif (browserGlobal) {\n  browserGlobal.Diamond = browserGlobal.Diamond || {};\n  browserGlobal.Diamond.transpile = transpile;\n}\n\nmodule.exports = api;\n"],
  "mappings": "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",
  "names": ["name", "body", "statement", "rightExpr", "callArgs", "text"]
}
